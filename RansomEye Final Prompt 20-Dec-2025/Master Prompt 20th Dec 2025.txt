# ğŸ§± RANSOMEYE â€” PHASE 1

## Program Governance, Military-Grade Foundations & Global Constraints

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 1)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_governance/`

---

## CONTEXT (NON-NEGOTIABLE)

You are building **RansomEye**, a:

* **Military-grade**
* **Enterprise-class**
* **Commercial, closed-source**
* **Zero-trust ransomware defense platform**
* **Production-ready from Day 1**

This system must be:

* Defensible in audits
* Survivable under attack
* Deterministic under failure
* Legally sellable
* Operational in air-gapped environments

**NO assumptions are allowed.**
**EVERY rule must be enforced by code, not documentation.**

---

## ğŸš¨ ABSOLUTE GLOBAL RULES (APPLY TO ALL PHASES)

These rules are **binding for the entire project**.

### 1. Licensing (FAIL-CLOSED)

**Allowed ONLY**

* MIT
* BSD 2-Clause / 3-Clause
* Apache 2.0
* PSF
* CC0

**Conditionally allowed**

* LGPL â†’ ONLY if dynamically linked and isolated

**BANNED (ABSOLUTE)**

* GPL v2 / v3
* AGPL
* SSPL
* Elastic License
* Unknown / custom licenses
* GPL rules, signatures, datasets, or content

â¡ï¸ **CI must block immediately on violation**

---

### 2. Programming Language Governance

| Layer             | Allowed Languages                           |
| ----------------- | ------------------------------------------- |
| Governance / Core | **Rust only**                               |
| DPI Probe         | **Rust + C++ + eBPF only**                  |
| Linux Agent       | **Rust (C only if unavoidable)**            |
| Windows Agent     | **Rust + C++**                              |
| AI / ML / LLM     | **Python (isolated) + Rust/C++ extensions** |
| Installers        | **Rust + Shell (orchestrator only)**        |

**Python is FORBIDDEN on hot paths.**

---

### 3. Configuration & Secrets

* ENV-only configuration
* No defaults for secrets
* Missing / invalid ENV â†’ **FAIL STARTUP**
* Unknown ENV variables â†’ **FAIL STARTUP**

---

### 4. Mandatory File Headers (NO EXCEPTIONS)

Every file MUST start with:

```
# Path: <absolute repo path>
# Author: RansomEye Core Team
# Purpose: <explicit purpose>
```

Applies to:
`.rs .c .cpp .py .sh .yaml .json .toml .service`

---

### 5. Data & AI Rules (CRITICAL)

* NO sample data committed
* NO runtime learning without baseline
* **ALL AI / ML / LLM MUST BE PRE-TRAINED FROM DAY 1**
* Incremental learning allowed ONLY on top of baseline
* SHAP explainability is mandatory for every numeric inference

---

### 6. Cryptographic Trust

* Every artifact signed
* Every signature verified before use
* Verification failure â†’ **BLOCK OPERATION**

---

## ğŸ¯ PHASE 1 OBJECTIVE

Phase 1 establishes **global governance, trust, safety, and enforcement primitives** that **ALL other phases depend on**.

This phase defines:

* Legal safety
* Build safety
* Supply-chain safety
* AI readiness from Day 1
* Installation legal acceptance (EULA)
* Operational invariants

**No business logic is allowed in Phase 1.**

---

## ğŸ“ PHASE 1 DIRECTORY STRUCTURE (MANDATORY)

Create exactly the following at:

```
/home/ransomeye/rebuild/ransomeye_governance/
```

```
ransomeye_governance/
â”œâ”€â”€ governance/
â”‚   â”œâ”€â”€ LICENSE_POLICY.md
â”‚   â”œâ”€â”€ THIRD_PARTY_POLICY.md
â”‚   â”œâ”€â”€ SECURITY_POLICY.md
â”‚   â”œâ”€â”€ AI_DAY1_READINESS.md
â”‚   â”œâ”€â”€ SUPPLY_CHAIN_SECURITY.md
â”‚   â””â”€â”€ CONTRIBUTION_RULES.md
â”‚
â”œâ”€â”€ eula/
â”‚   â””â”€â”€ EULA.txt          # EMPTY FILE â€“ MUST EXIST
â”‚
â”œâ”€â”€ ci/
â”‚   â”œâ”€â”€ license_scan.yml
â”‚   â”œâ”€â”€ header_enforcement.yml
â”‚   â”œâ”€â”€ secret_scan.yml
â”‚   â”œâ”€â”€ provenance.yml
â”‚   â””â”€â”€ artifact_signing.yml
â”‚
â”œâ”€â”€ tooling/
â”‚   â”œâ”€â”€ license_validator.py
â”‚   â”œâ”€â”€ header_validator.py
â”‚   â”œâ”€â”€ secret_validator.py
â”‚   â”œâ”€â”€ provenance_generator.py
â”‚   â””â”€â”€ artifact_signer.py
â”‚
â”œâ”€â”€ env/
â”‚   â””â”€â”€ env_schema.md
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ global_architecture_rules.md
â”‚   â”œâ”€â”€ zero_trust_principles.md
â”‚   â”œâ”€â”€ failure_philosophy.md
â”‚   â””â”€â”€ military_readiness_baseline.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ license_violation_tests.py
    â”œâ”€â”€ header_violation_tests.py
    â”œâ”€â”€ secret_violation_tests.py
    â””â”€â”€ ai_baseline_presence_tests.py
```

You MUST explain **why each directory exists** and **what it forbids**.

---

## ğŸ§  AI / ML / LLM â€” DAY-1 READINESS (MANDATORY FIX)

You MUST define a **Day-1 AI Baseline Doctrine**:

### REQUIRED CONCEPT:

**Signed Baseline Intelligence Pack**

Each RansomEye deployment MUST ship with:

* Pre-trained ransomware behavior models
* Pre-trained anomaly baselines
* Pre-trained confidence calibration
* Pre-generated SHAP reference distributions
* Pre-indexed LLM RAG corpus

Rules:

* AI MUST NOT start empty
* AI MUST NOT self-train without baseline
* AI output suppressed if baseline invalid

Document this fully in:

```
AI_DAY1_READINESS.md
```

---

## ğŸ“œ EULA ENFORCEMENT (MANDATORY)

Rules:

* Installation MUST fail unless EULA is accepted
* EULA file path is fixed:

  ```
  /home/ransomeye/rebuild/ransomeye_governance/eula/EULA.txt
  ```
* Acceptance must be logged
* Acceptance must be auditable
* Acceptance must be explicit (no implicit install)

No EULA = **NO INSTALL**

---

## ğŸ” SUPPLY-CHAIN SECURITY (MILITARY-GRADE)

You MUST define:

* Reproducible builds
* Build provenance
* SBOM generation
* Signed release manifests
* CI identity attestation

All documented in:

```
SUPPLY_CHAIN_SECURITY.md
```

---

## ğŸ§ª VALIDATION REQUIREMENTS (PHASE 1)

You MUST create tests that:

* Fail on GPL license
* Fail on missing AI baseline artifacts
* Fail on missing EULA file
* Fail on missing headers
* Fail on secret leakage

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 1 is INVALID if:

* Any GPL is tolerated
* AI baseline is optional
* EULA is not enforced
* Headers are optional
* Trust is implicit
* Anything â€œassumes later phases will fix itâ€

---

## FINAL INSTRUCTION (ABSOLUTE)

Treat Phase 1 as:

* A legal contract
* A military compliance framework
* A zero-trust constitution

If Phase 1 is weak, **the entire platform is invalid**.

**BUILD PHASE 1 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸ§© RANSOMEYE â€” PHASE 2

## System Architecture, Trust Boundaries & Data-Plane Separation

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 2)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_architecture/`

---

## CONTEXT (NON-NEGOTIABLE)

You are defining the **foundational architecture** of RansomEye.

This phase establishes:

* **Hard trust boundaries**
* **Data-plane vs control-plane separation**
* **Zero-trust assumptions**
* **Blast-radius containment**
* **Where AI/ML/LLM are allowed â€” and forbidden**

If this phase is wrong:

* DPI compromises Core
* Agents escalate privilege
* AI influences enforcement
* Scale claims collapse
* Military-grade posture is impossible

**This phase is purely architectural + enforcement primitives.
NO business logic, NO detection logic, NO policy logic.**

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1** apply **unchanged**.

Additional Phase-2-specific rules below **must be enforced by code**.

---

## ğŸ¯ PHASE 2 OBJECTIVE

Define and codify a **strict, provable, enforceable system architecture** that:

1. Clearly separates:

   * Data Plane
   * Control Plane
   * Intelligence Plane
   * Management Plane
2. Enforces **one-way trust flows**
3. Prevents **implicit coupling**
4. Ensures **DPI, Agents, Core, AI, LLM** cannot violate role boundaries
5. Guarantees **Day-1 AI readiness without enforcement authority**

---

## ğŸ§  ARCHITECTURAL PLANES (MANDATORY)

You MUST define **exactly these planes** and **no others**.

### 1. Data Plane (Untrusted Input Plane)

Components:

* DPI Probe (stand-alone)
* Linux Agent (stand-alone)
* Windows Agent (stand-alone)

Properties:

* High-volume
* Potentially hostile
* Never authoritative
* Never stateful long-term
* Never enforces policy

---

### 2. Control Plane (Authoritative Decision Plane)

Components:

* Core Correlation Engine
* Policy Engine
* Enforcement Dispatcher

Properties:

* Deterministic
* Fail-closed
* Fully signed inputs only
* No AI dependency
* Enforces policy

---

### 3. Intelligence Plane (Advisory Only)

Components:

* AI / ML Models
* Baseline Intelligence Pack
* Explainability (SHAP)
* Threat Intelligence Fusion
* LLM SOC Copilot

Properties:

* Fully trained Day-1
* Read-only inputs
* Advisory outputs only
* Never blocks
* Never enforces
* Never modifies state

---

### 4. Management Plane (Human Interface)

Components:

* UI
* Reporting
* Forensics
* Installer / Upgrader
* Audit & Compliance

Properties:

* Authenticated humans
* Audited actions
* Two-person integrity for critical ops
* No direct data-plane access

---

## ğŸ“ PHASE 2 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_architecture/
```

```
ransomeye_architecture/
â”œâ”€â”€ planes/
â”‚   â”œâ”€â”€ data_plane.md
â”‚   â”œâ”€â”€ control_plane.md
â”‚   â”œâ”€â”€ intelligence_plane.md
â”‚   â””â”€â”€ management_plane.md
â”‚
â”œâ”€â”€ trust/
â”‚   â”œâ”€â”€ trust_boundaries.md
â”‚   â”œâ”€â”€ trust_flow_diagrams.md
â”‚   â”œâ”€â”€ forbidden_flows.md
â”‚   â””â”€â”€ compromise_containment.md
â”‚
â”œâ”€â”€ identity/
â”‚   â”œâ”€â”€ component_identity.md
â”‚   â”œâ”€â”€ signing_model.md
â”‚   â”œâ”€â”€ verification_rules.md
â”‚   â””â”€â”€ revocation.md
â”‚
â”œâ”€â”€ data_contracts/
â”‚   â”œâ”€â”€ dpi_to_core.md
â”‚   â”œâ”€â”€ agent_to_core.md
â”‚   â”œâ”€â”€ core_to_ai.md
â”‚   â”œâ”€â”€ ai_to_human.md
â”‚   â””â”€â”€ enforcement_dispatch.md
â”‚
â”œâ”€â”€ swap_policy/
â”‚   â”œâ”€â”€ swap_requirements.md
â”‚   â””â”€â”€ enforcement_rules.md
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture_overview.md
â”‚   â”œâ”€â”€ zero_trust_model.md
â”‚   â”œâ”€â”€ day1_readiness.md
â”‚   â””â”€â”€ military_assumptions.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ forbidden_flow_tests.rs
    â”œâ”€â”€ identity_violation_tests.rs
    â”œâ”€â”€ ai_authority_violation_tests.rs
    â””â”€â”€ plane_isolation_tests.rs
```

Every document must define:

* What is allowed
* What is forbidden
* What happens on violation

---

## ğŸ” TRUST & IDENTITY MODEL (MANDATORY)

You MUST define:

* Unique cryptographic identity per component:

  * DPI Probe
  * Linux Agent
  * Windows Agent
  * Core Engine
  * AI Engine
  * LLM Engine
* Mutual authentication everywhere
* Explicit trust chains
* Revocation lists
* Identity expiration

**No shared secrets.
No implicit trust.**

---

## ğŸ” DATA FLOW RULES (HARD)

### Allowed (One-Way Only)

* DPI â†’ Core
* Agent â†’ Core
* Core â†’ Policy â†’ Enforcement
* Core â†’ AI (read-only)
* AI â†’ Human (advisory)

### Forbidden (Must Be Enforced)

* AI â†’ Core
* LLM â†’ Core
* DPI â†’ Policy
* Agent â†’ Policy
* Human â†’ Data Plane
* Human â†’ AI training without approval

Violation = **runtime termination + audit log**

---

## ğŸ§  AI / ML / LLM â€” ARCHITECTURAL CONSTRAINTS

You MUST explicitly define:

* AI has **zero enforcement authority**
* AI outputs are advisory
* AI confidence thresholds
* AI suppression rules
* AI baseline verification on startup
* AI shutdown behavior if baseline invalid

This MUST be documented in:

```
day1_readiness.md
```

---

## ğŸ§¾ DATA CONTRACT ENFORCEMENT

For every interface, define:

* Schema
* Versioning
* Signing requirements
* Size limits
* Rate limits
* Rejection behavior

No schema evolution without version bump.

---

## ğŸ’¾ SWAP MEMORY POLICY (MANDATORY FIX)

You MUST define and enforce:

### Applicable ONLY to:

* Core Engine machines
* DPI Probe machines

Rules:

* Minimum SWAP: **16 GB**
* OR **equal to physical RAM**, whichever is higher
* Automatically created during install
* Verified at startup
* Missing SWAP â†’ **FAIL STARTUP**

Explicitly forbidden for:

* Linux Agent
* Windows Agent

Document and enforce in:

```
swap_policy/
```

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST implement tests that:

* Reject forbidden trust flows
* Reject AI authority violations
* Reject unsigned data
* Reject missing swap on Core/DPI
* Reject identity misuse

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 2 is INVALID if:

* Trust boundaries are implicit
* AI can influence enforcement
* Planes are blurred
* Swap policy is undocumented or unenforced
* Data flow rules are advisory instead of enforced

---

## FINAL INSTRUCTION

Treat Phase 2 as:

* A **battlefield topology**
* A **blast-radius map**
* A **zero-trust contract**

If Phase 2 is violated anywhere later, **that module is invalid**.

**BUILD PHASE 2 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---
# ğŸ§  RANSOMEYE â€” PHASE 3

## Threat Intelligence, Baseline Intelligence Pack & Day-1 AI Readiness

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 3)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_intelligence/`

---

## CONTEXT (ABSOLUTE REQUIREMENT)

RansomEye **must not learn â€œlater.â€**
RansomEye **must defend from Day 1.**

This phase guarantees:

* AI/ML/LLM are **fully trained at installation**
* No cold-start blindness
* No empty models
* No speculative inference
* No runtime guessing

This phase builds the **entire intelligence substrate** used by:

* Correlation assistance
* Explainability
* Threat context
* SOC Copilot

**This phase has ZERO enforcement authority.**

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1 & Phase 2** apply unchanged.

Additional Phase-3 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 3 OBJECTIVE

Build a **signed, versioned, auditable Intelligence System** that:

1. Ships with **fully trained baseline AI/ML models**
2. Ships with **pre-indexed LLM RAG corpus**
3. Ships with **threat-intelligence knowledge packs**
4. Provides **explainable outputs from Day 1**
5. Never enforces decisions
6. Never trains implicitly
7. Never trusts runtime data without validation

---

## ğŸ§© INTELLIGENCE SUBSYSTEMS (MANDATORY)

You MUST implement **all** of the following:

### 1. Baseline Intelligence Pack (BIP)

### 2. Threat Intelligence Fusion Engine

### 3. AI / ML Model Registry (Day-1 Ready)

### 4. SHAP Explainability Baselines

### 5. LLM RAG Knowledge Store (Pre-Indexed)

No subsystem may be optional.

---

## ğŸ“ PHASE 3 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_intelligence/
```

```
ransomeye_intelligence/
â”œâ”€â”€ baseline_pack/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ ransomware_behavior.model
â”‚   â”‚   â”œâ”€â”€ anomaly_baseline.model
â”‚   â”‚   â”œâ”€â”€ confidence_calibration.model
â”‚   â”‚   â””â”€â”€ model_manifest.json
â”‚   â”‚
â”‚   â”œâ”€â”€ shap/
â”‚   â”‚   â”œâ”€â”€ baseline_shap_values.json
â”‚   â”‚   â””â”€â”€ shap_schema.json
â”‚   â”‚
â”‚   â”œâ”€â”€ metadata/
â”‚   â”‚   â”œâ”€â”€ training_manifest.json
â”‚   â”‚   â”œâ”€â”€ feature_schema.json
â”‚   â”‚   â””â”€â”€ license_manifest.json
â”‚   â”‚
â”‚   â””â”€â”€ signatures/
â”‚       â”œâ”€â”€ baseline_pack.sig
â”‚       â””â”€â”€ baseline_pack.pub
â”‚
â”œâ”€â”€ threat_intel/
â”‚   â”œâ”€â”€ ingestion/
â”‚   â”‚   â”œâ”€â”€ offline_feeds.rs
â”‚   â”‚   â””â”€â”€ feed_validator.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ normalization/
â”‚   â”‚   â”œâ”€â”€ ontology.rs
â”‚   â”‚   â””â”€â”€ mapping.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ fusion/
â”‚   â”‚   â”œâ”€â”€ correlation.rs
â”‚   â”‚   â””â”€â”€ confidence.rs
â”‚   â”‚
â”‚   â””â”€â”€ signatures/
â”‚       â””â”€â”€ intel_pack.sig
â”‚
â”œâ”€â”€ ai_registry/
â”‚   â”œâ”€â”€ registry.rs
â”‚   â”œâ”€â”€ versioning.rs
â”‚   â”œâ”€â”€ verification.rs
â”‚   â””â”€â”€ rollback.rs
â”‚
â”œâ”€â”€ llm_knowledge/
â”‚   â”œâ”€â”€ rag_index/
â”‚   â”‚   â”œâ”€â”€ index.bin
â”‚   â”‚   â””â”€â”€ index_manifest.json
â”‚   â”‚
â”‚   â”œâ”€â”€ documents/
â”‚   â”‚   â”œâ”€â”€ ransomware_playbooks.md
â”‚   â”‚   â”œâ”€â”€ kill_chain_reference.md
â”‚   â”‚   â”œâ”€â”€ policy_explanations.md
â”‚   â”‚   â””â”€â”€ forensics_guides.md
â”‚   â”‚
â”‚   â””â”€â”€ signatures/
â”‚       â””â”€â”€ rag_pack.sig
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ signature_verification.rs
â”‚   â”œâ”€â”€ trust_chain.rs
â”‚   â””â”€â”€ revocation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ day1_intelligence.md
â”‚   â”œâ”€â”€ baseline_training_methodology.md
â”‚   â”œâ”€â”€ threat_intel_governance.md
â”‚   â”œâ”€â”€ explainability_guarantees.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ baseline_presence_tests.rs
    â”œâ”€â”€ signature_failure_tests.rs
    â”œâ”€â”€ shap_completeness_tests.rs
    â”œâ”€â”€ intel_poisoning_tests.rs
    â””â”€â”€ llm_index_integrity_tests.rs
```

---

## ğŸ§  BASELINE INTELLIGENCE PACK (MANDATORY)

### REQUIRED CONTENT

The Baseline Pack MUST include:

* Pre-trained ransomware behavior models
* Pre-trained anomaly detection models
* Confidence calibration curves
* SHAP baseline distributions
* Feature schemas
* Training provenance

### TRAINING RULES

* Training uses **synthetic + red-team generated datasets**
* No customer data
* No external runtime learning
* Training artifacts must be reproducible

### STARTUP RULE

If Baseline Pack:

* Missing
* Invalid
* Unsigned
* Expired

â¡ï¸ **AI subsystem MUST NOT START**

---

## ğŸ§¬ THREAT INTELLIGENCE FUSION (STRICT)

Rules:

* Intel is **advisory**
* Intel never overrides Core logic
* Intel confidence must be explicit
* Intel sources must be signed
* Intel poisoning must be detectable

Intel informs:

* Correlation context
* SOC explanations
* Analyst workflows

---

## ğŸ” SHAP EXPLAINABILITY (DAY-1 GUARANTEE)

You MUST enforce:

* SHAP available for every numeric inference
* Baseline SHAP present at install
* SHAP schema validation
* SHAP verification

Missing SHAP = **BLOCK inference**

---

## ğŸ§  LLM RAG KNOWLEDGE (PRE-INDEXED)

Rules:

* RAG index built at release time
* No live indexing at install
* Documents signed and verified
* Queries read-only
* Evidence-linked responses only

LLM MUST NOT:

* Train
* Fine-tune
* Learn implicitly

---

## ğŸ” SECURITY & TRUST (MANDATORY)

You MUST enforce:

* Signature verification on every pack
* Trust chain validation
* Revocation handling
* Version compatibility

Failure = **Subsystem disabled + audit log**

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Ensure AI never starts empty
* Ensure SHAP always exists
* Detect intel poisoning
* Detect model tampering
* Detect RAG index corruption

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 3 is INVALID if:

* AI can start without baseline
* Threat intel can override decisions
* SHAP is optional
* LLM can mutate knowledge
* Intelligence trust is implicit

---

## FINAL INSTRUCTION

Treat Phase 3 as:

* Your **strategic intelligence doctrine**
* Your **Day-1 readiness guarantee**
* Your **anti-guessing firewall**

If Phase 3 is weak, **RansomEye is blind at install time**.

**BUILD PHASE 3 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸ”„ RANSOMEYE â€” PHASE 4

## Core Event Ingestion, Secure Streaming & Deterministic Backpressure

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 4)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_ingestion/`

---

## CONTEXT (NON-NEGOTIABLE)

This phase builds the **only ingress point** into the RansomEye **Control Plane**.

All data entering Core:

* Comes from **untrusted sources**
* May be malformed, malicious, replayed, or flooded
* Must be authenticated, verified, normalized, and rate-controlled

This phase must:

* Protect Core from overload
* Preserve ordering where required
* Enforce strict schemas
* Apply **deterministic backpressure**
* Fail closed under stress

**No correlation, no policy, no AI inference is allowed here.**

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“3** apply unchanged.

Additional Phase-4 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 4 OBJECTIVE

Build a **hardened ingestion and streaming subsystem** that:

1. Authenticates every producer
2. Verifies signatures on every event
3. Enforces strict schemas and versions
4. Applies deterministic rate-limits
5. Applies bounded buffering with backpressure
6. Preserves event integrity and traceability
7. Delivers only validated events to the Core Correlation Engine

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Mutual authentication
* Signature verification
* Schema validation
* Version compatibility checks
* Rate limiting
* Backpressure signaling
* Event normalization
* Integrity metadata attachment

### MUST NEVER DO

* Correlate events
* Store long-term data
* Invoke AI/ML/LLM
* Modify semantic meaning
* Trust producers implicitly
* Drop events silently

---

## ğŸ“ PHASE 4 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_ingestion/
```

```
ransomeye_ingestion/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ server.rs
â”‚   â”œâ”€â”€ listener.rs
â”‚   â”œâ”€â”€ auth.rs
â”‚   â”œâ”€â”€ signature.rs
â”‚   â”œâ”€â”€ schema.rs
â”‚   â”œâ”€â”€ versioning.rs
â”‚   â”œâ”€â”€ normalization.rs
â”‚   â”œâ”€â”€ rate_limit.rs
â”‚   â”œâ”€â”€ backpressure.rs
â”‚   â”œâ”€â”€ buffer.rs
â”‚   â”œâ”€â”€ ordering.rs
â”‚   â””â”€â”€ dispatcher.rs
â”‚
â”œâ”€â”€ protocol/
â”‚   â”œâ”€â”€ event_schema_v1.json
â”‚   â”œâ”€â”€ event_envelope.rs
â”‚   â””â”€â”€ compatibility.md
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ identity.rs
â”‚   â”œâ”€â”€ trust_chain.rs
â”‚   â”œâ”€â”€ replay_protection.rs
â”‚   â””â”€â”€ revocation.rs
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ env_schema.md
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ ingestion_flow.md
â”‚   â”œâ”€â”€ backpressure_model.md
â”‚   â”œâ”€â”€ rate_limit_policy.md
â”‚   â”œâ”€â”€ trust_enforcement.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ auth_failure_tests.rs
    â”œâ”€â”€ signature_failure_tests.rs
    â”œâ”€â”€ schema_rejection_tests.rs
    â”œâ”€â”€ overload_tests.rs
    â”œâ”€â”€ backpressure_tests.rs
    â””â”€â”€ replay_attack_tests.rs
```

Every module must explicitly document:

* Inputs
* Outputs
* Failure behavior
* Performance characteristics

---

## ğŸ” AUTHENTICATION & TRUST (MANDATORY)

You MUST enforce:

* Mutual TLS (or equivalent)
* Per-producer identity
* Identity expiration
* Revocation checking
* Replay protection (nonce / timestamp)

Any failure â†’ **REJECT EVENT + AUDIT LOG**

---

## ğŸ§¾ EVENT ENVELOPE (MANDATORY)

Every event MUST include:

* Producer ID
* Component type (DPI / Linux Agent / Windows Agent)
* Schema version
* Timestamp
* Sequence number
* Cryptographic signature
* Integrity hash

Unsigned or malformed events â†’ **REJECT**

---

## âš™ï¸ RATE LIMITING & BACKPRESSURE (CRITICAL)

You MUST define:

* Per-producer rate limits
* Per-component quotas
* Global ingestion caps
* Bounded buffers (no unbounded queues)
* Backpressure signaling to producers
* Explicit rejection when limits exceeded

Rules:

* No silent drops
* No best-effort buffering
* No memory exhaustion allowed

---

## ğŸ” ORDERING GUARANTEES

You MUST explicitly define:

* What is ordered (per producer, per flow, etc.)
* What is not ordered
* How reordering is handled
* How gaps are handled

Ordering must be **explicitly bounded**.

---

## ğŸ”’ SECURITY & ISOLATION

You MUST enforce:

* No shared memory with Core
* No mutable global state
* No cross-producer contamination
* Fail-closed on internal error

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST implement tests that:

* Flood ingestion with synthetic events
* Spoof producer identities
* Replay events
* Exceed rate limits
* Corrupt schemas
* Exhaust buffers

All tests must be deterministic.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Producer flooding
* Invalid signatures
* Schema mismatches
* Buffer exhaustion
* Core downstream unavailability
* Network partitions

Failures must:

* Be logged
* Be observable
* Never propagate corruption

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 4 is INVALID if:

* Any event bypasses verification
* Backpressure is implicit
* Silent drops exist
* Ordering is assumed
* AI is invoked
* Trust is implicit

---

## FINAL INSTRUCTION

Treat Phase 4 as:

* A **blast-shield**
* A **traffic control tower**
* A **firewall for logic**

If Phase 4 fails, **Core must never see corrupted data**.

**BUILD PHASE 4 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---



# ğŸ§  RANSOMEYE â€” PHASE 5

## Core Correlation Engine, Kill-Chain Inference & Deterministic Detection

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 5)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_core/`

---

## CONTEXT (SECURITY-CRITICAL)

This phase builds the **Core Correlation Engine**, which is the **only component allowed to infer â€œattack realityâ€**.

This engine:

* Receives only **validated events from Phase 4**
* Operates **deterministically**
* Implements **formal ransomware kill-chain logic**
* Produces **authoritative detection outputs**
* Feeds **Policy Engine (Phase 6)**

If this phase is wrong:

* False positives explode
* Attacks are missed
* Enforcement becomes arbitrary
* Military-grade claims fail

**This phase MUST NOT depend on AI/ML/LLM to function.**
AI is **assistive context only**, never authoritative.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“4** apply unchanged.

Additional Phase-5 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 5 OBJECTIVE

Build a **deterministic, explainable, formally bounded correlation engine** that:

1. Correlates multi-source telemetry
2. Tracks entity state over time
3. Implements a **formal ransomware kill-chain**
4. Infers attack progression deterministically
5. Produces confidence-scored detection outputs
6. Emits explainability artifacts
7. Operates at **50,000+ endpoints scale**

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Temporal correlation
* Cross-signal correlation
* Entity state tracking
* Kill-chain stage inference
* Deterministic scoring
* Explainability generation
* Bounded memory management

### MUST NEVER DO

* Enforce policy
* Block traffic
* Execute response actions
* Invoke AI/ML/LLM for decisions
* Trust upstream data implicitly
* Learn at runtime

---

## ğŸ“ PHASE 5 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_core/
```

```
ransomeye_core/
â”œâ”€â”€ correlation/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ engine.rs
â”‚   â”‚   â”œâ”€â”€ scheduler.rs
â”‚   â”‚   â”œâ”€â”€ entity_state.rs
â”‚   â”‚   â”œâ”€â”€ temporal.rs
â”‚   â”‚   â”œâ”€â”€ graph.rs
â”‚   â”‚   â”œâ”€â”€ scoring.rs
â”‚   â”‚   â”œâ”€â”€ explainability.rs
â”‚   â”‚   â””â”€â”€ invariants.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ kill_chain/
â”‚   â”‚   â”œâ”€â”€ stages.rs
â”‚   â”‚   â”œâ”€â”€ transitions.rs
â”‚   â”‚   â”œâ”€â”€ rules.rs
â”‚   â”‚   â””â”€â”€ inference.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â”œâ”€â”€ validated_events.rs
â”‚   â”‚   â””â”€â”€ normalization.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ detection_result.rs
â”‚   â”‚   â”œâ”€â”€ confidence.rs
â”‚   â”‚   â””â”€â”€ rationale.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ correlation_errors.rs
â”‚
â”œâ”€â”€ intelligence_adapter/
â”‚   â”œâ”€â”€ threat_context.rs
â”‚   â”œâ”€â”€ ai_context.rs
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ correlation_model.md
â”‚   â”œâ”€â”€ kill_chain_model.md
â”‚   â”œâ”€â”€ invariants.md
â”‚   â”œâ”€â”€ performance_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_attack_tests.rs
    â”œâ”€â”€ false_positive_tests.rs
    â”œâ”€â”€ ordering_tests.rs
    â”œâ”€â”€ scale_tests.rs
    â”œâ”€â”€ invariant_violation_tests.rs
    â””â”€â”€ determinism_tests.rs
```

---

## ğŸ§¬ FORMAL KILL-CHAIN MODEL (MANDATORY)

You MUST implement a **formal ransomware-specific kill-chain**, including at minimum:

* Initial access
* Execution
* Persistence
* Privilege escalation
* Lateral movement
* Credential access
* Discovery
* Encryption preparation
* Encryption execution
* Impact

Each stage MUST define:

* Entry conditions
* Required signals
* Temporal constraints
* Allowed transitions
* Regression rules
* Confidence decay

No generic â€œMITRE-onlyâ€ mapping.
This must be ransomware-specific and codified.

---

## ğŸ§  DETERMINISM & INVARIANTS (CRITICAL)

You MUST define and enforce **hard invariants**, such as:

* No stage skip without evidence
* No confidence increase without new signal
* No detection without minimum signal set
* No state explosion without eviction

Violating an invariant â†’ **FAIL CLOSED + AUDIT LOG**

---

## âš™ï¸ PERFORMANCE & SCALE MODEL

You MUST explicitly define:

* Event throughput limits
* Memory bounds per entity
* Eviction strategy
* Lock-free or low-lock design
* Scheduler fairness
* Backpressure interaction with Phase 4

No unbounded maps.
No global locks.

---

## ğŸ” EXPLAINABILITY (MANDATORY)

For every detection result, you MUST emit:

* Signals involved
* Kill-chain stages triggered
* Temporal sequence
* Confidence calculation
* Intelligence context used (if any)

Explainability must be:

* Human readable
* Machine readable
* Deterministic

---

## ğŸ§  INTELLIGENCE USAGE (STRICT)

Allowed:

* Threat intel as context
* AI confidence hints
* Baseline anomaly context

Forbidden:

* AI overriding correlation
* AI injecting detections
* AI altering state transitions

If intelligence is unavailable:
â¡ï¸ Core MUST continue functioning.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Event floods
* Out-of-order events
* Entity explosion
* Memory pressure
* Internal state corruption
* Downstream unavailability

Failures must:

* Preserve correctness
* Avoid false detection
* Remain observable

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Replay synthetic ransomware campaigns
* Verify determinism
* Validate invariants
* Test scale limits (50k+ entities)
* Confirm explainability completeness

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 5 is INVALID if:

* AI influences decisions
* Kill-chain is implicit
* Determinism is not provable
* Invariants are undocumented
* Memory is unbounded
* Correlation logic is heuristic-only

---

## FINAL INSTRUCTION

Treat Phase 5 as:

* A **formal reasoning engine**
* A **court-defensible detector**
* A **zero-guessing brain**

If Phase 5 is weak, **everything downstream is unsafe**.

**BUILD PHASE 5 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---


# ğŸ›¡ï¸ RANSOMEYE â€” PHASE 6

## Policy Engine, Enforcement Semantics & Cryptographic Control

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 6)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_policy/`

---

## CONTEXT (HIGHEST RISK ZONE)

This phase is where **decisions become actions**.

The Policy Engine:

* Is the **only authority** that may authorize enforcement
* Must be **deterministic, auditable, and fail-closed**
* Must operate **without AI dependency**
* Must be **provably correct under ambiguity**

Any ambiguity, unsigned input, or undefined behavior **must result in NO ACTION**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“5** apply unchanged.

Additional Phase-6 rules are **hard enforcement**.

---

## ğŸ¯ PHASE 6 OBJECTIVE

Build a **cryptographically enforced Policy Engine** that:

1. Accepts **only** detections from Phase 5
2. Loads **only signed policies**
3. Evaluates policies deterministically
4. Resolves conflicts explicitly
5. Emits **explicit, scoped, reversible enforcement directives**
6. Produces a complete **audit trail**
7. Fails closed on any uncertainty

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Policy signature verification
* Schema and version validation
* Deterministic evaluation
* Explicit conflict resolution
* Directive generation with scope & TTL
* Audit logging (append-only)

### MUST NEVER DO

* Guess intent
* Modify detections
* Invoke AI/ML/LLM
* Execute enforcement locally
* Continue on verification failure

---

## ğŸ“ PHASE 6 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_policy/
```

```
ransomeye_policy/
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ engine.rs
â”‚   â”‚   â”œâ”€â”€ evaluator.rs
â”‚   â”‚   â”œâ”€â”€ precedence.rs
â”‚   â”‚   â”œâ”€â”€ conflict.rs
â”‚   â”‚   â”œâ”€â”€ compiler.rs
â”‚   â”‚   â”œâ”€â”€ enforcement.rs
â”‚   â”‚   â””â”€â”€ audit.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ policy_errors.rs
â”‚
â”œâ”€â”€ language/
â”‚   â”œâ”€â”€ grammar.md
â”‚   â”œâ”€â”€ semantics.md
â”‚   â”œâ”€â”€ determinism_rules.md
â”‚   â””â”€â”€ examples/
â”‚       â”œâ”€â”€ block_encryption.policy
â”‚       â”œâ”€â”€ isolate_host.policy
â”‚       â””â”€â”€ monitor_only.policy
â”‚
â”œâ”€â”€ schema/
â”‚   â”œâ”€â”€ policy_schema.json
â”‚   â”œâ”€â”€ directive_schema.json
â”‚   â””â”€â”€ versioning.md
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ signature.rs
â”‚   â”œâ”€â”€ verification.rs
â”‚   â”œâ”€â”€ trust_chain.rs
â”‚   â””â”€â”€ revocation.rs
â”‚
â”œâ”€â”€ output/
â”‚   â”œâ”€â”€ directive.rs
â”‚   â”œâ”€â”€ receipt.rs
â”‚   â””â”€â”€ audit_record.rs
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ evaluation_pipeline.md
â”‚   â”œâ”€â”€ conflict_resolution.md
â”‚   â”œâ”€â”€ enforcement_model.md
â”‚   â”œâ”€â”€ compliance.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ signed_policy_tests.rs
    â”œâ”€â”€ conflict_tests.rs
    â”œâ”€â”€ precedence_tests.rs
    â”œâ”€â”€ determinism_tests.rs
    â”œâ”€â”€ fail_closed_tests.rs
    â””â”€â”€ audit_integrity_tests.rs
```

---

## ğŸ“œ POLICY LANGUAGE (FORMAL & SAFE)

You MUST define a **restricted policy language** with:

* No loops
* No dynamic execution
* No external calls
* No user-defined functions
* Deterministic evaluation order

Policy MUST define:

* Scope (entity, host, network, time)
* Preconditions (from Phase 5 outputs)
* Action(s)
* TTL / expiration
* Rollback behavior
* Priority

---

## ğŸ” SIGNING & TRUST (MANDATORY)

Policies MUST:

* Be signed with approved keys
* Include author, version, scope, validity window
* Pass trust-chain verification
* Be rejected if expired, revoked, or malformed

Failure â†’ **NO POLICY LOADED**

---

## ğŸ”€ EVALUATION PIPELINE (EXPLICIT)

Define and implement, in order:

1. Input verification (detections)
2. Policy signature verification
3. Schema & version validation
4. Deterministic evaluation
5. Conflict detection
6. Conflict resolution (explicit rules)
7. Directive creation
8. Audit record append
9. Dispatch to Enforcement Dispatcher

Any failure â†’ **ABORT & LOG**

---

## ğŸ§­ CONFLICT RESOLUTION (MANDATORY)

You MUST define:

* Priority rules
* Specificity rules
* Time-bound overrides
* Explicit deny precedence
* No silent resolution

Conflicts without resolution â†’ **NO ACTION**

---

## ğŸ§¾ ENFORCEMENT DIRECTIVES (STRICT)

Directives MUST include:

* Unique ID
* Target scope
* Action type
* TTL
* Preconditions
* Rollback instructions
* Signature
* Nonce

Directives MUST be:

* Idempotent
* Reversible
* Time-bounded

---

## ğŸ” AUDIT & NON-REPUDIATION

You MUST implement:

* Append-only audit log
* Hash-chained records
* Signed receipts
* Verifiable replay

Audit failure â†’ **BLOCK ENFORCEMENT**

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Missing policy
* Invalid signature
* Conflicting policies
* Unsupported versions
* Internal errors
* Resource exhaustion

All must **fail closed**.

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Reject unsigned policies
* Enforce determinism
* Detect conflicts
* Verify audit immutability
* Validate rollback semantics

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 6 is INVALID if:

* Unsigned policies are accepted
* Evaluation order is implicit
* Conflicts auto-resolve silently
* AI influences policy
* Fail-open behavior exists

---

## FINAL INSTRUCTION

Treat Phase 6 as:

* A **legal contract engine**
* A **safety governor**
* A **non-repudiable authority**

If Phase 6 is weak, **RansomEye cannot be trusted to act**.

**BUILD PHASE 6 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸšš RANSOMEYE â€” PHASE 7

## Enforcement Dispatcher, Stand-Alone Module Integration & Safety Guards

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 7)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_dispatcher/`

---

## CONTEXT (CRITICAL SAFETY LAYER)

This phase is the **only bridge** between:

* **Authoritative policy decisions (Phase 6)**
  and
* **Stand-alone executors**:

  * DPI Probe
  * Linux Agent
  * Windows Agent

This layer **does not decide**, **does not infer**, and **does not enforce locally**.

It **only transports**, **verifies**, **tracks**, and **confirms** enforcement actions.

Any mistake here can:

* Execute the wrong action
* Execute on the wrong host
* Execute without rollback
* Execute without audit

This phase must therefore be **extremely strict and conservative**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“6** apply unchanged.

Additional Phase-7 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 7 OBJECTIVE

Build a **deterministic, cryptographically enforced Enforcement Dispatcher** that:

1. Accepts **only signed directives** from Phase 6
2. Validates scope, TTL, and preconditions
3. Delivers directives to correct stand-alone modules
4. Enforces execution acknowledgment
5. Enforces rollback if execution fails
6. Maintains end-to-end auditability
7. Never executes enforcement itself

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Directive verification
* Target resolution
* Secure delivery
* Execution tracking
* Acknowledgment verification
* Timeout handling
* Rollback coordination
* Audit logging

### MUST NEVER DO

* Modify directives
* Re-interpret policy
* Execute enforcement locally
* Retry blindly
* Trust agents implicitly

---

## ğŸ“ PHASE 7 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_dispatcher/
```

```
ransomeye_dispatcher/
â”œâ”€â”€ dispatcher/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ dispatcher.rs
â”‚   â”‚   â”œâ”€â”€ verifier.rs
â”‚   â”‚   â”œâ”€â”€ router.rs
â”‚   â”‚   â”œâ”€â”€ delivery.rs
â”‚   â”‚   â”œâ”€â”€ acknowledgment.rs
â”‚   â”‚   â”œâ”€â”€ timeout.rs
â”‚   â”‚   â”œâ”€â”€ rollback.rs
â”‚   â”‚   â””â”€â”€ audit.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ dispatcher_errors.rs
â”‚
â”œâ”€â”€ protocol/
â”‚   â”œâ”€â”€ directive_envelope.rs
â”‚   â”œâ”€â”€ acknowledgment_schema.json
â”‚   â””â”€â”€ versioning.md
â”‚
â”œâ”€â”€ targets/
â”‚   â”œâ”€â”€ dpi.rs
â”‚   â”œâ”€â”€ linux_agent.rs
â”‚   â””â”€â”€ windows_agent.rs
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ signature.rs
â”‚   â”œâ”€â”€ trust_chain.rs
â”‚   â”œâ”€â”€ nonce.rs
â”‚   â””â”€â”€ replay_protection.rs
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ dispatcher_flow.md
â”‚   â”œâ”€â”€ execution_guarantees.md
â”‚   â”œâ”€â”€ rollback_model.md
â”‚   â”œâ”€â”€ blast_radius.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ directive_validation_tests.rs
    â”œâ”€â”€ misrouting_tests.rs
    â”œâ”€â”€ timeout_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â””â”€â”€ replay_attack_tests.rs
```

---

## ğŸ” DIRECTIVE VERIFICATION (MANDATORY)

Before delivery, dispatcher MUST verify:

* Policy Engine signature
* Directive signature
* Directive TTL
* Target scope
* Preconditions hash
* Nonce freshness

Any failure â†’ **DO NOT DELIVER**

---

## ğŸ¯ TARGET RESOLUTION (STRICT)

Dispatcher MUST:

* Resolve exact target(s)
* Validate agent identity
* Validate agent capability
* Validate platform compatibility

If ambiguity exists â†’ **ABORT**

---

## ğŸ”„ DELIVERY & ACKNOWLEDGMENT FLOW

You MUST implement:

1. Directive verification
2. Target resolution
3. Secure delivery (mutual auth)
4. Agent execution
5. Signed acknowledgment
6. Result verification
7. Audit record append

Missing acknowledgment within TTL â†’ **ROLLBACK INITIATED**

---

## ğŸ§¯ ROLLBACK & SAFETY GUARDS

Rollback MUST:

* Be explicit
* Be signed
* Restore previous state
* Be auditable
* Be time-bounded

Rollback failure â†’ **ESCALATE + ALERT**

---

## ğŸ” AUDIT & TRACEABILITY

Dispatcher MUST maintain:

* Delivery receipts
* Execution acknowledgments
* Rollback records
* Hash-chained logs

All records must be:

* Append-only
* Signed
* Verifiable

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Invalid directives
* Agent unreachable
* Partial execution
* Timeout without acknowledgment
* Replay attempts
* Identity mismatch

Failures must:

* Preserve safety
* Avoid repeated harm
* Be observable

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Deliver to wrong agent (must fail)
* Replay directives
* Corrupt acknowledgments
* Force rollback
* Exhaust retries

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 7 is INVALID if:

* Dispatcher executes enforcement
* Unsigned directives are delivered
* Rollback is optional
* Target ambiguity is tolerated
* Acknowledgment is best-effort

---

## FINAL INSTRUCTION

Treat Phase 7 as:

* A **weapons safety system**
* A **dead-man switch**
* A **blast-radius governor**

If Phase 7 fails, **RansomEye becomes dangerous**.

**BUILD PHASE 7 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸ¤– RANSOMEYE â€” PHASE 8

## AI/ML Inference, Explainability & Analyst Assistance (Day-1 Ready, Advisory Only)

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 8)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_ai/`

---

## CONTEXT (STRICT ISOLATION)

This phase wires **fully trained AI/ML/LLM** into RansomEye **from Day 1** to:

* Reduce analyst load
* Provide explainability
* Provide context and recommendations

**This phase has ZERO enforcement authority.**
**If this phase fails, Core must continue safely.**

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“7** apply unchanged.

Additional Phase-8 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 8 OBJECTIVE

Build a **Day-1 ready, fully trained, explainable AI/ML/LLM subsystem** that:

1. Loads **signed baseline models** at startup
2. Performs **read-only inference**
3. Emits **confidence + SHAP** for every numeric output
4. Provides **human-readable explanations**
5. Supports **incremental learning only with explicit approval**
6. Never influences policy or enforcement
7. Operates offline / air-gapped

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Verify baseline intelligence packs
* Perform inference deterministically
* Generate SHAP for every inference
* Attach rationale and confidence
* Provide analyst-friendly summaries
* Log every inference for audit

### MUST NEVER DO

* Enforce actions
* Modify Core state
* Retrain implicitly
* Operate without baseline
* Guess without confidence
* Access raw secrets

---

## ğŸ“ PHASE 8 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_ai/
```

```
ransomeye_ai/
â”œâ”€â”€ baseline/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ ransomware_behavior.model
â”‚   â”‚   â”œâ”€â”€ anomaly_baseline.model
â”‚   â”‚   â””â”€â”€ calibration.model
â”‚   â”œâ”€â”€ shap/
â”‚   â”‚   â””â”€â”€ baseline_shap.json
â”‚   â””â”€â”€ signatures/
â”‚       â””â”€â”€ baseline.sig
â”‚
â”œâ”€â”€ inference/
â”‚   â”œâ”€â”€ predictor.py
â”‚   â”œâ”€â”€ confidence.py
â”‚   â”œâ”€â”€ safeguards.py
â”‚   â””â”€â”€ invariants.py
â”‚
â”œâ”€â”€ explainability/
â”‚   â”œâ”€â”€ shap_generator.py
â”‚   â”œâ”€â”€ shap_schema.json
â”‚   â””â”€â”€ artifact_writer.py
â”‚
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ runtime.py
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ incident_summary.txt
â”‚   â”‚   â”œâ”€â”€ kill_chain_explain.txt
â”‚   â”‚   â””â”€â”€ analyst_qa.txt
â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”œâ”€â”€ index.bin
â”‚   â”‚   â””â”€â”€ retriever.py
â”‚   â””â”€â”€ guardrails.py
â”‚
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ read_only_adapter.rs
â”‚   â””â”€â”€ contract.rs
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ model_verification.py
â”‚   â”œâ”€â”€ prompt_signing.py
â”‚   â””â”€â”€ trust_chain.py
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ day1_training.md
â”‚   â”œâ”€â”€ inference_flow.md
â”‚   â”œâ”€â”€ explainability.md
â”‚   â”œâ”€â”€ llm_guardrails.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ baseline_presence_tests.py
    â”œâ”€â”€ shap_completeness_tests.py
    â”œâ”€â”€ hallucination_tests.py
    â”œâ”€â”€ drift_detection_tests.py
    â””â”€â”€ integrity_tests.py
```

---

## ğŸ§  DAY-1 TRAINING REQUIREMENTS (MANDATORY)

You MUST ensure:

* Baseline models are **pre-trained before release**
* Training provenance is documented
* Feature schemas are frozen
* Calibration curves included
* SHAP baseline distributions included

If any baseline artifact is missing or invalid:
â¡ï¸ **AI subsystem MUST NOT START**

---

## ğŸ” SHAP EXPLAINABILITY (NON-NEGOTIABLE)

Rules:

* SHAP for **every numeric inference**
* Stored with inference output
* Signed and verifiable
* Human + machine readable

Missing SHAP â†’ **BLOCK inference**

---

## ğŸ§  LLM SOC ASSISTANT (READ-ONLY)

LLM rules:

* Local model only
* Pre-indexed RAG only
* No learning
* No external calls
* Evidence-linked responses
* Confidence disclosure

LLM MUST NOT:

* Suggest actions
* Trigger workflows
* Modify state
* Bypass Core

---

## ğŸ” SECURITY & TRUST (MANDATORY)

You MUST enforce:

* Model signature verification
* Prompt signature verification
* Version pinning
* Trust-chain validation
* Revocation handling

Failure â†’ **Subsystem disabled + audit log**

---

## ğŸ”„ INCREMENTAL LEARNING (CONTROLLED)

Allowed ONLY if:

* Explicit admin approval
* Signed training package
* Offline training
* Re-signing of new baseline
* Full audit trail

No background learning.
No silent updates.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Missing baseline
* Invalid signature
* SHAP generation failure
* Drift detected
* LLM hallucination detected

Failures must:

* Degrade safely
* Never affect enforcement
* Be observable

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Verify Day-1 readiness
* Verify SHAP completeness
* Detect hallucinations
* Detect model tampering
* Validate read-only contracts

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 8 is INVALID if:

* AI can start empty
* AI influences policy
* SHAP is optional
* LLM accesses live systems
* Incremental learning is implicit

---

## FINAL INSTRUCTION

Treat Phase 8 as:

* A **trained advisor**
* A **court-defensible explainer**
* A **non-authoritative assistant**

If Phase 8 fails, **humans lose insight but security remains intact**.

**BUILD PHASE 8 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---


# ğŸ“¡ RANSOMEYE â€” PHASE 9A

## DPI Probe (Stand-Alone) â€” High-Throughput Data Plane Sensor

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 9A)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_dpi_probe/`

---

## CONTEXT (DATA PLANE, HOSTILE ENVIRONMENT)

The DPI Probe is a **stand-alone, untrusted-input sensor** operating at **line rate (40+ Gbps)**.
It **never decides**, **never enforces**, and **never stores long-term state**.

Assumptions:

* Traffic is hostile
* NICs are saturated
* CPUs are NUMA
* Memory pressure exists
* Kernel features vary across Linux versions

The DPI Probe must protect itself and the Core by **sampling, normalizing, and streaming metadata only**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“8** apply unchanged.

Additional Phase-9A rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 9A OBJECTIVE

Build a **GPL-free, Linux-agnostic, ultra-high-performance DPI Probe** that:

1. Captures packets at line rate
2. Reconstructs flows/sessions (bounded)
3. Extracts metadata (no payload storage)
4. Generates **signed events** only
5. Applies deterministic backpressure
6. Streams to Core Ingestion (Phase 4)
7. Enforces **SWAP policy** at startup
8. Operates without Python or GC

---

## ğŸš« LICENSE & LANGUAGE RULES (STRICT)

### Languages (ONLY)

* **Rust (PRIMARY)**
* **C++ (ONLY if unavoidable for perf)**
* **eBPF (kernel space only)**

### Forbidden

* Python
* Go
* Java
* NodeJS
* Scapy
* Any GPL userland library

### Allowed Libraries

* libpcap (BSD)
* AF_XDP
* Hyperscan (BSD)
* MIT/BSD/Apache crates only

---

## ğŸ’¾ SWAP MEMORY POLICY (MANDATORY)

Applicable **ONLY** to:

* DPI Probe
* Core Engine

Rules:

* Minimum SWAP: **16 GB**
* OR **equal to physical RAM**, whichever is higher
* Automatically created during install
* Verified at startup
* Missing/insufficient SWAP â†’ **FAIL STARTUP**

Explicitly **FORBIDDEN** for:

* Linux Agent
* Windows Agent

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Packet capture
* Flow/session tracking (bounded)
* Metadata extraction (headers, TLS FP, timing)
* Event signing
* Rate limiting
* Backpressure signaling
* Self-identity verification

### MUST NEVER DO

* Payload storage
* Policy enforcement
* AI inference
* Traffic blocking
* Database writes
* Trust upstream/downstream blindly

---

## ğŸ“ PHASE 9A DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_dpi_probe/
```

```
ransomeye_dpi_probe/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ capture/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ pcap.rs
â”‚   â”‚   â”œâ”€â”€ af_xdp.rs
â”‚   â”‚   â””â”€â”€ interface.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ pipeline/
â”‚   â”‚   â”œâ”€â”€ packet_decoder.rs
â”‚   â”‚   â”œâ”€â”€ flow_tracker.rs
â”‚   â”‚   â”œâ”€â”€ session_reassembly.rs
â”‚   â”‚   â””â”€â”€ metadata_extractor.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ threading/
â”‚   â”‚   â”œâ”€â”€ cpu_pinning.rs
â”‚   â”‚   â”œâ”€â”€ numa.rs
â”‚   â”‚   â””â”€â”€ backpressure.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ event_schema.rs
â”‚   â”‚   â”œâ”€â”€ serializer.rs
â”‚   â”‚   â””â”€â”€ secure_stream.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ attestation.rs
â”‚   â”‚   â””â”€â”€ signing.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ system/
â”‚   â”‚   â”œâ”€â”€ swap_check.rs
â”‚   â”‚   â””â”€â”€ env_validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ dpi_errors.rs
â”‚
â”œâ”€â”€ ebpf/
â”‚   â”œâ”€â”€ xdp_program.c
â”‚   â”œâ”€â”€ maps.h
â”‚   â””â”€â”€ loader.rs
â”‚
â”œâ”€â”€ systemd/
â”‚   â””â”€â”€ ransomeye-dpi-probe.service
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ packet_pipeline.md
â”‚   â”œâ”€â”€ threading_model.md
â”‚   â”œâ”€â”€ memory_model.md
â”‚   â”œâ”€â”€ swap_policy.md
â”‚   â”œâ”€â”€ kernel_compatibility.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_packets.rs
    â”œâ”€â”€ throughput_40gbps.rs
    â”œâ”€â”€ backpressure_tests.rs
    â”œâ”€â”€ swap_enforcement_tests.rs
    â””â”€â”€ tamper_tests.rs
```

---

## âš™ï¸ PERFORMANCE & THREADING MODEL (MANDATORY)

You MUST define and implement:

* Per-CPU worker threads
* CPU pinning
* NUMA locality
* Zero-copy buffers
* Lock-free queues
* Fixed memory pools

ğŸš« No per-packet allocation
ğŸš« No global locks
ğŸš« No unbounded buffers

---

## ğŸ”€ PACKET â†’ EVENT PIPELINE (EXPLICIT)

Define step-by-step:

1. NIC â†’ Kernel (AF_XDP/libpcap)
2. Kernel â†’ Userland
3. Packet decode
4. Flow/session tracking
5. Metadata extraction
6. Event normalization
7. Signature generation
8. Secure stream to Phase 4

Each step must specify:

* Input
* Output
* Failure behavior
* Performance impact

---

## ğŸ” IDENTITY & TRUST (MANDATORY)

* Unique cryptographic identity per probe
* Mutual auth with Core ingestion
* Attestation before streaming
* Signature on every event
* Replay protection

Failure â†’ **STOP STREAMING**

---

## ğŸ§  AI / ML / LLM (STRICTLY ADVISORY)

DPI Probe:

* **DOES NOT RUN AI**
* **DOES NOT INFER**
* **DOES NOT SCORE**

Allowed:

* Embedding metadata fields required by AI later
* Feature-ready extraction only

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Packet overload
* CPU starvation
* Memory pressure
* Swap missing
* Core unreachable
* Identity invalid
* Kernel feature missing

Failures must:

* Be observable
* Be safe
* Avoid packet corruption
* Never block traffic

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Prove 40+ Gbps sustained ingest (synthetic)
* Validate swap enforcement
* Detect signature tampering
* Validate backpressure
* Validate kernel compatibility

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 9A is INVALID if:

* GPL appears anywhere
* Swap is optional
* Python exists
* DPI enforces policy
* Packets are stored
* Silent drops exist

---

## FINAL INSTRUCTION

Treat Phase 9A as:

* A **carrier-grade sensor**
* A **blast-shield**
* A **data-plane appliance**

If DPI fails, **Core must survive**.

**BUILD PHASE 9A COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---
# ğŸ§ RANSOMEYE â€” PHASE 9B

## Linux Agent (Stand-Alone) â€” Host Sensor & Controlled Enforcer

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 9B)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_linux_agent/`

---

## CONTEXT (ENDPOINT TRUST BOUNDARY)

The Linux Agent operates **on potentially compromised hosts** and must assume:

* Hostile local users
* Partial privilege loss
* Kernel feature variability
* Offline / air-gapped operation

This agent is **stand-alone** and:

* Collects host-level telemetry
* Executes **only explicitly authorized enforcement**
* Never correlates across hosts
* Never infers attacks
* Never depends on AI to function

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“8** apply unchanged.

Additional Phase-9B rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 9B OBJECTIVE

Build a **minimal-footprint, Linux-agnostic, cryptographically controlled Linux Agent** that:

1. Collects host telemetry safely
2. Normalizes and signs telemetry events
3. Receives **signed enforcement directives only**
4. Executes enforcement safely and reversibly
5. Maintains strong identity and integrity
6. Operates without swap
7. Works across **any Linux distribution** (no assumptions)

---

## ğŸš« LANGUAGE & LICENSE RULES (STRICT)

### Allowed Languages

* **Rust (PRIMARY)**
* **C (ONLY if kernel interaction is unavoidable)**

### Forbidden

* Python
* Go
* Java
* NodeJS
* Shell as core logic
* GPL userland libraries

All dependencies must be **MIT / BSD / Apache 2.0**.

---

## ğŸ’¾ SWAP POLICY (EXPLICIT)

* **Swap usage is FORBIDDEN**
* Agent must not create, require, or depend on swap
* Memory usage must be bounded
* Swap checks must explicitly skip Linux Agent

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Process activity telemetry
* File system metadata telemetry
* System integrity signals
* Kernel / OS metadata capture
* Secure communication with Core ingestion
* Signed enforcement execution
* Self-integrity verification

### MUST NEVER DO

* Policy decisions
* Cross-host correlation
* AI inference
* Runtime learning
* Unsigned execution
* OS destabilization

---

## ğŸ“ PHASE 9B DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_linux_agent/
```

```
ransomeye_linux_agent/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ agent.rs
â”‚   â”œâ”€â”€ lifecycle.rs
â”‚   â”œâ”€â”€ telemetry/
â”‚   â”‚   â”œâ”€â”€ process.rs
â”‚   â”‚   â”œâ”€â”€ filesystem.rs
â”‚   â”‚   â”œâ”€â”€ memory.rs
â”‚   â”‚   â”œâ”€â”€ kernel.rs
â”‚   â”‚   â””â”€â”€ system.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ enforcement/
â”‚   â”‚   â”œâ”€â”€ actions.rs
â”‚   â”‚   â”œâ”€â”€ safeguards.rs
â”‚   â”‚   â””â”€â”€ rollback.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ comms/
â”‚   â”‚   â”œâ”€â”€ protocol.rs
â”‚   â”‚   â”œâ”€â”€ encryption.rs
â”‚   â”‚   â””â”€â”€ retry.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ verification.rs
â”‚   â”‚   â””â”€â”€ integrity.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ system/
â”‚   â”‚   â””â”€â”€ env_validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ agent_errors.rs
â”‚
â”œâ”€â”€ systemd/
â”‚   â””â”€â”€ ransomeye-linux-agent.service
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ telemetry_model.md
â”‚   â”œâ”€â”€ enforcement_model.md
â”‚   â”œâ”€â”€ kernel_compatibility.md
â”‚   â”œâ”€â”€ security_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_telemetry.rs
    â”œâ”€â”€ enforcement_safety_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â”œâ”€â”€ tamper_tests.rs
    â””â”€â”€ offline_mode_tests.rs
```

---

## ğŸ” IDENTITY & TRUST (MANDATORY)

You MUST enforce:

* Unique per-agent cryptographic identity
* Secure enrollment bootstrap
* Mutual authentication with Core ingestion
* Signature verification on every directive
* Identity expiration and revocation

Verification failure â†’ **REFUSE EXECUTION**

---

## ğŸ“Š TELEMETRY MODEL (SAFE & BOUNDED)

Telemetry MUST be:

* Metadata-only
* Rate-limited
* Privacy-aware
* Schema-validated
* Signed before transmission

No raw file contents
No credential material
No memory dumps

---

## ğŸ›¡ï¸ ENFORCEMENT MODEL (STRICT & SAFE)

Enforcement actions MUST be:

* Explicit
* Signed
* Scoped
* Time-bounded
* Reversible

Agent MUST refuse:

* Unsigned directives
* Over-broad scope
* Unsafe operations
* Missing rollback instructions

---

## ğŸ” AI / ML / LLM INTERACTION (ADVISORY ONLY)

Linux Agent:

* **Does NOT run AI**
* **Does NOT infer**
* **Does NOT score**

Allowed:

* Emit telemetry fields required by AI later
* Receive human-visible context (never actions)

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Kernel feature unavailable
* Privilege loss
* Disk full
* Network isolation
* Identity expiration
* Binary tampering

Agent must:

* Remain observable
* Avoid OS instability
* Fail safely without blocking host

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Validate Linux distro neutrality
* Validate no-swap enforcement
* Validate signed enforcement only
* Validate rollback correctness
* Validate offline operation

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 9B is INVALID if:

* Swap is used
* Python exists
* Enforcement is implicit
* Identity trust is assumed
* Kernel assumptions exist
* Unsigned actions execute

---

## FINAL INSTRUCTION

Treat the Linux Agent as:

* A **low-trust execution surface**
* A **high-integrity sensor**
* A **surgical enforcer**

If the Linux Agent fails, **it must not damage the host**.

**BUILD PHASE 9B COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸªŸ RANSOMEYE â€” PHASE 9C

## Windows Agent (Stand-Alone) â€” Native Endpoint Sensor & Controlled Enforcer

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 9C)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_windows_agent/`

---

## CONTEXT (WINDOWS ENDPOINT TRUST BOUNDARY)

The Windows Agent operates on **enterprise-hardened and potentially compromised Windows hosts**.

Assumptions:

* Hostile local users may exist
* Privileges may be restricted or revoked
* System is protected by AV/EDR/Defender
* System may be offline or air-gapped

The Windows Agent is **stand-alone** and:

* Collects **native Windows telemetry**
* Executes **only explicitly authorized enforcement**
* Never correlates across hosts
* Never infers attacks
* Never depends on AI/ML/LLM to function

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“8** apply unchanged.

Additional Phase-9C rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 9C OBJECTIVE

Build a **native, low-overhead, cryptographically controlled Windows Agent** that:

1. Collects Windows-native telemetry safely
2. Normalizes and signs telemetry events
3. Receives **signed enforcement directives only**
4. Executes enforcement safely and reversibly
5. Maintains strong identity and self-integrity
6. Operates without swap
7. Works across **supported Windows Server & Desktop versions**

---

## ğŸš« LANGUAGE & LICENSE RULES (STRICT)

### Allowed Languages

* **Rust (PRIMARY orchestration & security)**
* **C++ (MANDATORY for Windows-native subsystems)**

### Forbidden

* Python
* Java
* Go
* NodeJS
* PowerShell as core logic
* Any interpreter-based runtime

Allowed libraries:

* Windows SDK
* ETW APIs
* MIT / BSD / Apache 2.0 libraries only

---

## ğŸ’¾ SWAP POLICY (EXPLICIT)

* **Swap usage is FORBIDDEN**
* Agent must not create, require, or depend on swap
* Memory usage must be bounded
* Swap checks must explicitly skip Windows Agent

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Process & thread telemetry
* File system metadata telemetry
* Registry activity telemetry
* ETW-based event capture
* Secure communication with Core ingestion
* Signed enforcement execution
* Self-integrity & tamper detection

### MUST NEVER DO

* Policy decisions
* Cross-host correlation
* AI inference
* Runtime learning
* Unsigned execution
* OS destabilization

---

## ğŸ“ PHASE 9C DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_windows_agent/
```

```
ransomeye_windows_agent/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ agent.rs
â”‚   â”œâ”€â”€ lifecycle.rs
â”‚   â”œâ”€â”€ telemetry/
â”‚   â”‚   â”œâ”€â”€ process.cpp
â”‚   â”‚   â”œâ”€â”€ filesystem.cpp
â”‚   â”‚   â”œâ”€â”€ registry.cpp
â”‚   â”‚   â”œâ”€â”€ etw.cpp
â”‚   â”‚   â”œâ”€â”€ memory.cpp
â”‚   â”‚   â””â”€â”€ system.cpp
â”‚   â”‚
â”‚   â”œâ”€â”€ enforcement/
â”‚   â”‚   â”œâ”€â”€ actions.rs
â”‚   â”‚   â”œâ”€â”€ safeguards.rs
â”‚   â”‚   â””â”€â”€ rollback.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ comms/
â”‚   â”‚   â”œâ”€â”€ protocol.rs
â”‚   â”‚   â”œâ”€â”€ encryption.rs
â”‚   â”‚   â””â”€â”€ retry.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ verification.rs
â”‚   â”‚   â””â”€â”€ integrity.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ system/
â”‚   â”‚   â””â”€â”€ env_validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ agent_errors.rs
â”‚
â”œâ”€â”€ installer/
â”‚   â”œâ”€â”€ msi/
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ ransomeye-windows-agent.service
â”‚   â””â”€â”€ upgrade.md
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ telemetry_model.md
â”‚   â”œâ”€â”€ etw_model.md
â”‚   â”œâ”€â”€ enforcement_model.md
â”‚   â”œâ”€â”€ security_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_telemetry.rs
    â”œâ”€â”€ etw_failure_tests.rs
    â”œâ”€â”€ enforcement_safety_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â””â”€â”€ offline_mode_tests.rs
```

---

## ğŸ” IDENTITY & TRUST (MANDATORY)

You MUST enforce:

* Unique per-agent cryptographic identity
* Secure enrollment & bootstrap
* Mutual authentication with Core ingestion
* Signature verification on every directive
* Identity expiration & revocation

Verification failure â†’ **REFUSE EXECUTION**

---

## ğŸ“Š TELEMETRY MODEL (SAFE & BOUNDED)

Telemetry MUST be:

* Metadata-only
* Rate-limited
* Privacy-aware
* Schema-validated
* Signed before transmission

Explicitly forbidden:

* Credential harvesting
* Raw memory dumps
* File content exfiltration

---

## ğŸ›¡ï¸ ENFORCEMENT MODEL (STRICT & SAFE)

Enforcement actions MUST be:

* Explicit
* Signed
* Scoped
* Time-bounded
* Reversible

Agent MUST refuse:

* Unsigned directives
* Over-broad scope
* Unsafe operations
* Missing rollback instructions

---

## ğŸ” AI / ML / LLM INTERACTION (ADVISORY ONLY)

Windows Agent:

* **DOES NOT run AI**
* **DOES NOT infer**
* **DOES NOT score**

Allowed:

* Emit telemetry fields required by AI later
* Display human-readable advisory context

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* ETW provider failure
* Privilege loss
* Service restart
* Disk exhaustion
* Network isolation
* Identity expiration
* Binary tampering

Agent must:

* Remain observable
* Avoid OS instability
* Fail safely without blocking Windows

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Validate supported Windows versions
* Validate no-swap enforcement
* Validate signed enforcement only
* Validate rollback correctness
* Validate offline operation

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 9C is INVALID if:

* Swap is used
* Python exists
* Enforcement is implicit
* Identity trust is assumed
* ETW is replaced with polling
* Unsigned actions execute

---

## FINAL INSTRUCTION

Treat the Windows Agent as:

* A **high-value target**
* A **low-trust environment component**
* A **precise execution surface**

If the Windows Agent fails, **it must not destabilize the OS**.

**BUILD PHASE 9C COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸ“Š RANSOMEYE â€” PHASE 10

## Reporting, Forensics, Evidence Preservation & Audit Outputs

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 10)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_reporting/`

---

## CONTEXT (LEGAL & FORENSIC GRADE)

This phase produces **evidence**, not dashboards.

All outputs from this phase may be:

* Used in internal incident response
* Presented to auditors
* Shared with regulators
* Submitted in legal proceedings

Therefore:

* **Nothing may be altered**
* **Nothing may be inferred**
* **Nothing may be hidden**
* **Everything must be verifiable**

If this phase is weak, **RansomEye is legally indefensible**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“9C** apply unchanged.

Additional Phase-10 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 10 OBJECTIVE

Build an **audit-grade, forensically sound reporting and evidence system** that:

1. Produces **immutable evidence artifacts**
2. Preserves full chain-of-custody
3. Supports **PDF, HTML, CSV**
4. Cryptographically signs every report
5. Guarantees reproducibility
6. Exposes explainability artifacts (from Phase 8)
7. Never mutates original detection data

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Snapshot validated outputs only
* Generate cryptographic hashes at capture time
* Sign evidence and reports
* Maintain chain-of-custody logs
* Support independent verification
* Export in required formats

### MUST NEVER DO

* Re-run detection logic
* Modify evidence post-capture
* Hide uncertainty or confidence
* Aggregate beyond source meaning
* Allow mutable storage

---

## ğŸ“ PHASE 10 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_reporting/
```

```
ransomeye_reporting/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ collector.rs
â”‚   â”œâ”€â”€ evidence.rs
â”‚   â”œâ”€â”€ hash.rs
â”‚   â”œâ”€â”€ signature.rs
â”‚   â”œâ”€â”€ custody.rs
â”‚   â”œâ”€â”€ manifest.rs
â”‚   â””â”€â”€ exporter.rs
â”‚
â”œâ”€â”€ formats/
â”‚   â”œâ”€â”€ pdf.rs
â”‚   â”œâ”€â”€ html.rs
â”‚   â””â”€â”€ csv.rs
â”‚
â”œâ”€â”€ schema/
â”‚   â”œâ”€â”€ evidence_schema.json
â”‚   â”œâ”€â”€ report_schema.json
â”‚   â””â”€â”€ metadata_schema.json
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ signing.rs
â”‚   â”œâ”€â”€ verification.rs
â”‚   â””â”€â”€ key_management.md
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ evidence_model.md
â”‚   â”œâ”€â”€ chain_of_custody.md
â”‚   â”œâ”€â”€ report_contents.md
â”‚   â”œâ”€â”€ legal_defensibility.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ immutability_tests.rs
    â”œâ”€â”€ hash_verification_tests.rs
    â”œâ”€â”€ signature_tests.rs
    â”œâ”€â”€ format_parity_tests.rs
    â””â”€â”€ tamper_detection_tests.rs
```

---

## ğŸ” CHAIN OF CUSTODY (MANDATORY)

You MUST implement:

* Evidence ID generation
* Capture timestamps (monotonic + wall-clock)
* Hash-at-capture
* Immutable custody log entries
* Signed custody transitions

Every access, export, or verification:

* Must append a custody record
* Must be signed
* Must be verifiable independently

---

## ğŸ“‘ REPORT CONTENT (MANDATORY & FIXED)

Each report MUST include:

* Incident identifier
* Detection timeline
* Entities involved
* Kill-chain stages (from Phase 5)
* Policy decisions (from Phase 6)
* Enforcement directives & outcomes (Phase 7)
* AI explainability references (Phase 8)
* Confidence values
* Analyst annotations (clearly marked)
* Cryptographic hashes
* Verification instructions

No speculative language allowed.

---

## ğŸ“¤ OUTPUT FORMAT RULES

### PDF

* Human-readable
* Signed
* Watermarked with Report ID
* Embedded hash summary

### HTML

* Self-contained
* Read-only
* Embedded verification metadata

### CSV

* Raw data only
* No interpretation
* Each row hash-referenced

---

## ğŸ”€ DATA FLOW (STRICT & IMMUTABLE)

Define and enforce:

1. Input selection (validated only)
2. Evidence snapshot
3. Hash generation
4. Signature application
5. Format rendering
6. Output sealing
7. Verification workflow

At no point may data mutate.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Missing evidence
* Hash mismatch
* Signature failure
* Partial export
* Disk exhaustion

Any failure â†’ **ABORT OUTPUT, PRESERVE ORIGINAL EVIDENCE**

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Prove immutability
* Detect tampering
* Validate cross-format parity
* Verify reproducibility
* Validate custody integrity

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 10 is INVALID if:

* Evidence can be modified
* Hashing is optional
* Reports are unsigned
* Formats diverge semantically
* Python mutates evidence

---

## FINAL INSTRUCTION

Treat Phase 10 outputs as:

* **Court-admissible artifacts**
* **Immutable truth records**
* **Externally verifiable proof**

If Phase 10 is weak, **RansomEye cannot be trusted beyond SOC dashboards**.

**BUILD PHASE 10 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# âš™ï¸ RANSOMEYE â€” PHASE 11

## Unified Installer, Uninstaller, EULA Enforcement & Operations

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 11)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_installer/`

**Scope Note (STRICT):**
This phase applies to **ALL modules** via a **unified installer/uninstaller** **EXCEPT**:

* **DPI Probe** (stand-alone)
* **Linux Agent** (stand-alone)
* **Windows Agent** (stand-alone)

Those stand-alone modules have **their own installers** and are **explicitly excluded** from unified installer logic.

---

## CONTEXT (ENTERPRISE & LEGAL CRITICAL)

This phase determines whether RansomEye can be:

* Installed safely
* Operated in air-gapped environments
* Upgraded without outages
* Rolled back deterministically
* Uninstalled cleanly
* Legally distributed (EULA)

Any mistake here can:

* Brick hosts
* Violate license terms
* Break trust with customers
* Prevent rollback during incidents

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“10** apply unchanged.

Additional Phase-11 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 11 OBJECTIVE

Build a **transactional, deterministic, legally enforced installer/uninstaller** that:

1. Enforces **explicit EULA acceptance**
2. Performs **preflight validation**
3. Creates and validates **SWAP** (Core & DPI only)
4. Installs all **non-stand-alone modules**
5. Verifies **signatures & integrity**
6. Supports **upgrade, rollback, uninstall**
7. Works **offline / air-gapped**
8. Centralizes **systemd units**
9. Leaves system safe on failure

---

## ğŸ“¦ INSTALLER RESPONSIBILITIES (STRICT)

### MUST DO

* Display and require EULA acceptance
* Validate environment before install
* Verify signatures for every artifact
* Enforce version compatibility
* Perform atomic installs
* Create/verify swap (Core only here)
* Support rollback on failure
* Log deterministically

### MUST NEVER DO

* Assume internet access
* Modify OS security silently
* Proceed on validation failure
* Leave partial installs
* Skip EULA
* Install stand-alone modules

---

## ğŸ“ PHASE 11 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_installer/
```

```
ransomeye_installer/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ eula.rs
â”‚   â”œâ”€â”€ preflight.rs
â”‚   â”œâ”€â”€ verify.rs
â”‚   â”œâ”€â”€ install.rs
â”‚   â”œâ”€â”€ upgrade.rs
â”‚   â”œâ”€â”€ rollback.rs
â”‚   â”œâ”€â”€ uninstall.rs
â”‚   â”œâ”€â”€ swap.rs
â”‚   â””â”€â”€ logging.rs
â”‚
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ ingestion/
â”‚   â”œâ”€â”€ policy/
â”‚   â”œâ”€â”€ dispatcher/
â”‚   â”œâ”€â”€ ai/
â”‚   â”œâ”€â”€ reporting/
â”‚   â””â”€â”€ intelligence/
â”‚
â”œâ”€â”€ systemd/
â”‚   â”œâ”€â”€ ransomeye-core.service
â”‚   â”œâ”€â”€ ransomeye-ingestion.service
â”‚   â”œâ”€â”€ ransomeye-policy.service
â”‚   â”œâ”€â”€ ransomeye-dispatcher.service
â”‚   â”œâ”€â”€ ransomeye-ai.service
â”‚   â””â”€â”€ ransomeye-reporting.service
â”‚
â”œâ”€â”€ eula/
â”‚   â””â”€â”€ EULA.txt   # EMPTY FILE â€” MUST EXIST & BE ACCEPTED
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ install_schema.md
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ install.sh
â”‚   â”œâ”€â”€ upgrade.sh
â”‚   â”œâ”€â”€ rollback.sh
â”‚   â”œâ”€â”€ uninstall.sh
â”‚   â””â”€â”€ verify.sh
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ installation_guide.md
â”‚   â”œâ”€â”€ upgrade_guide.md
â”‚   â”œâ”€â”€ rollback_guide.md
â”‚   â”œâ”€â”€ uninstall_guide.md
â”‚   â”œâ”€â”€ airgap_guide.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ preflight_tests.rs
    â”œâ”€â”€ eula_enforcement_tests.rs
    â”œâ”€â”€ swap_creation_tests.rs
    â”œâ”€â”€ upgrade_failure_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â””â”€â”€ uninstall_tests.rs
```

---

## ğŸ“œ EULA ENFORCEMENT (MANDATORY, NON-NEGOTIABLE)

Rules:

* EULA file path is fixed:

  ```
  /home/ransomeye/rebuild/ransomeye_installer/eula/EULA.txt
  ```
* Installer MUST:

  * Display EULA
  * Require explicit acceptance (yes/no)
  * Record acceptance (timestamp, user, host)
* No acceptance â†’ **ABORT INSTALL**
* Acceptance must be auditable

No silent installs.

---

## ğŸ” PREFLIGHT VALIDATION (MANDATORY)

You MUST validate:

* OS compatibility
* Kernel features
* Disk space
* Memory availability
* Required capabilities
* Conflicting services
* Existing versions
* Architecture compatibility

Any failure â†’ **ABORT**

---

## ğŸ’¾ SWAP MANAGEMENT (MANDATORY)

### Applies ONLY to:

* **Core Engine**
* **DPI Probe** (handled by DPI installer; unified installer validates Core only)

Rules for Core:

* Minimum SWAP: **16 GB**
* OR **equal to physical RAM**, whichever is higher
* Create swap file deterministically
* Persist across reboot
* Verify at startup

Failure â†’ **ABORT INSTALL**

Explicitly forbidden for:

* Linux Agent
* Windows Agent

---

## ğŸ” SECURITY & INTEGRITY (MANDATORY)

Installer MUST:

* Verify signatures for every package
* Verify checksums
* Validate trust chain
* Reject unsigned or modified artifacts

Any failure â†’ **ABORT**

---

## ğŸ”„ UPGRADE & ROLLBACK (TRANSACTIONAL)

You MUST implement:

* Rolling upgrades (where applicable)
* Mixed-version compatibility checks
* Config migration with backup
* Automatic rollback on failure

Rollback MUST:

* Restore binaries
* Restore configs
* Restore services
* Leave system operational

---

## ğŸ§¹ UNINSTALL (CLEAN & SAFE)

Uninstall MUST:

* Stop services
* Remove binaries
* Preserve logs (optional, configurable)
* Remove swap ONLY if created by installer
* Leave OS unchanged otherwise

No orphaned services.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define explicit behavior for:

* Power loss mid-install
* Disk full mid-install
* Invalid EULA
* Signature failure
* Version mismatch
* Partial upgrade

System must always be recoverable.

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Enforce EULA acceptance
* Verify swap creation
* Simulate upgrade failures
* Verify rollback correctness
* Validate uninstall safety
* Validate air-gapped install

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 11 is INVALID if:

* EULA can be bypassed
* Swap is optional for Core
* Partial installs persist
* Rollback is best-effort
* Stand-alone modules are installed here

---

## FINAL INSTRUCTION

Treat Phase 11 as:

* A **legal gate**
* An **operational safety system**
* A **transaction manager**

If Phase 11 fails, **enterprises will not trust deployment**.

**BUILD PHASE 11 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---


# ğŸ§ª RANSOMEYE â€” PHASE 12

## Validation, Stress, Security, Scale & Release Gate

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 12 | FINAL)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_validation/`

---

## CONTEXT (NO COMPROMISE)

This phase decides whether **RansomEye is releasable**.

Nothing ships unless **every prior phase is proven** to:

* Behave deterministically
* Fail closed
* Scale to enterprise extremes
* Remain safe under attack
* Defend from **Day 1** with **fully trained AI/ML/LLM**

This is not QA.
This is **operational proof under hostile conditions**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“11** apply unchanged.

Additional Phase-12 rules are **hard enforcement**.

---

## ğŸ¯ PHASE 12 OBJECTIVE

Build a **comprehensive, automated validation and stress framework** that:

1. Verifies **every phase contract**
2. Stress-tests **50,000+ endpoints**
3. Validates **40+ Gbps DPI throughput**
4. Proves **determinism and fail-closed behavior**
5. Validates **AI/ML/LLM Day-1 readiness**
6. Simulates **active attacker behavior**
7. Produces **release certification artifacts**

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* End-to-end validation
* Adversarial testing
* Load and stress testing
* Fault injection
* Determinism verification
* Security posture validation
* Produce signed release reports

### MUST NEVER DO

* Modify production code
* Relax constraints
* Skip failing tests
* Mask nondeterminism
* Disable safeguards

---

## ğŸ“ PHASE 12 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_validation/
```

```
ransomeye_validation/
â”œâ”€â”€ harness/
â”‚   â”œâ”€â”€ orchestrator.rs
â”‚   â”œâ”€â”€ environment.rs
â”‚   â”œâ”€â”€ fault_injection.rs
â”‚   â””â”€â”€ metrics.rs
â”‚
â”œâ”€â”€ scenarios/
â”‚   â”œâ”€â”€ ransomware_campaigns/
â”‚   â”‚   â”œâ”€â”€ locker_simulation.yaml
â”‚   â”‚   â”œâ”€â”€ lateral_movement.yaml
â”‚   â”‚   â””â”€â”€ mass_encryption.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ benign_load/
â”‚   â”‚   â”œâ”€â”€ enterprise_burst.yaml
â”‚   â”‚   â””â”€â”€ maintenance_window.yaml
â”‚   â”‚
â”‚   â””â”€â”€ attacker_behaviors/
â”‚       â”œâ”€â”€ evasion.yaml
â”‚       â”œâ”€â”€ replay.yaml
â”‚       â””â”€â”€ poisoning.yaml
â”‚
â”œâ”€â”€ scale/
â”‚   â”œâ”€â”€ endpoint_scale.rs
â”‚   â”œâ”€â”€ dpi_throughput.rs
â”‚   â””â”€â”€ memory_pressure.rs
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ trust_violation.rs
â”‚   â”œâ”€â”€ signature_attack.rs
â”‚   â”œâ”€â”€ privilege_escalation.rs
â”‚   â””â”€â”€ tamper_tests.rs
â”‚
â”œâ”€â”€ ai_validation/
â”‚   â”œâ”€â”€ day1_readiness.rs
â”‚   â”œâ”€â”€ shap_coverage.rs
â”‚   â”œâ”€â”€ hallucination.rs
â”‚   â””â”€â”€ drift_detection.rs
â”‚
â”œâ”€â”€ determinism/
â”‚   â”œâ”€â”€ replay_tests.rs
â”‚   â”œâ”€â”€ ordering_tests.rs
â”‚   â””â”€â”€ invariant_checks.rs
â”‚
â”œâ”€â”€ reports/
â”‚   â”œâ”€â”€ release_certificate.md
â”‚   â”œâ”€â”€ risk_register.md
â”‚   â”œâ”€â”€ coverage_report.md
â”‚   â””â”€â”€ known_limitations.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ end_to_end.rs
    â”œâ”€â”€ fail_closed.rs
    â”œâ”€â”€ overload.rs
    â”œâ”€â”€ rollback.rs
    â””â”€â”€ recovery.rs
```

---

## ğŸ”„ END-TO-END VALIDATION (MANDATORY)

You MUST validate complete flows:

1. DPI / Agents â†’ Ingestion
2. Ingestion â†’ Core Correlation
3. Core â†’ Policy Engine
4. Policy â†’ Dispatcher
5. Dispatcher â†’ Stand-alone Agents
6. Evidence â†’ Reporting
7. AI â†’ Analyst only (no authority)

Every flow must be:

* Signed
* Audited
* Deterministic

---

## ğŸ“ˆ SCALE & STRESS (NON-NEGOTIABLE)

You MUST prove:

* **50,000+ endpoints** simulated concurrently
* Sustained DPI ingest at **40+ Gbps**
* Backpressure correctness
* Bounded memory usage
* No global lock collapse
* Swap behavior correct (Core & DPI only)

Failure anywhere â†’ **FAIL RELEASE**

---

## ğŸ” SECURITY & ADVERSARIAL TESTING

You MUST simulate:

* Identity spoofing
* Signature forgery
* Replay attacks
* Policy tampering
* Agent compromise
* AI poisoning attempts

Expected behavior:

* Detection
* Rejection
* Audit
* No enforcement without authority

---

## ğŸ§  AI / ML / LLM DAY-1 VALIDATION (MANDATORY)

You MUST prove:

* Baseline models exist and load
* SHAP generated for every inference
* LLM operates offline
* No inference without explainability
* No AI influence on enforcement
* No cold-start conditions

AI subsystem failure must:

* Disable AI only
* Leave Core operational

---

## ğŸ” DETERMINISM & FAIL-CLOSED

You MUST prove:

* Identical inputs â†’ identical outputs
* Order variance handled explicitly
* No race-condition detection drift
* Any ambiguity â†’ NO ACTION
* Any verification failure â†’ FAIL CLOSED

---

## ğŸ’¥ FAULT INJECTION (MANDATORY)

Inject and validate behavior for:

* Network partitions
* Disk exhaustion
* CPU starvation
* Memory pressure
* Swap removal (Core/DPI)
* Partial upgrades
* Power loss mid-operation

System must:

* Remain safe
* Recover deterministically
* Preserve audit trails

---

## ğŸ“œ RELEASE ARTIFACTS (MANDATORY)

You MUST produce:

* **Release Certificate** (signed)
* **Coverage Report**
* **Risk Register**
* **Known Limitations**
* **Reproducibility Instructions**

No release without signed artifacts.

---

## ğŸ›‘ RELEASE FAILURE CONDITIONS (ABSOLUTE)

Phase 12 FAILS if:

* Any phase violates contracts
* Any nondeterminism exists
* AI is not Day-1 ready
* Enforcement occurs on ambiguity
* Swap rules are violated
* GPL contamination exists
* EULA enforcement is bypassable

---

## FINAL INSTRUCTION

Treat Phase 12 as:

* A **weapons test range**
* A **courtroom rehearsal**
* A **battlefield simulation**

Only if Phase 12 passes **completely** is RansomEye considered:

> **MILITARY-GRADE, ENTERPRISE-READY, DAY-1 DEFENSIVE**

**BUILD PHASE 12 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---

# ğŸ”´ RANSOMEYE â€” RED-TEAM PLAYBOOKS

## (Authoritative Adversarial Validation Set)

---

## ğŸ¯ RED-TEAM OBJECTIVES (NON-NEGOTIABLE)

Each playbook MUST attempt to:

1. Bypass trust boundaries
2. Cause false enforcement
3. Suppress real detection
4. Break determinism
5. Poison intelligence
6. Exploit scale (50k+ endpoints)
7. Force fail-open behavior

**Success is defined as:**
RansomEye **detects, resists, fails closed, logs, and recovers**.

---

# PLAYBOOK GROUP A â€” DATA PLANE ATTACKS

*(DPI + Agents)*

---

## ğŸ”´ RT-01: DPI FLOOD & MEMORY EXHAUSTION

**Goal:**
Crash DPI or force silent packet drops at 40+ Gbps.

**Attack Simulation:**

* Mixed packet sizes (64Bâ€“9KB)
* TCP/UDP/QUIC blend
* Out-of-order fragments
* Burst floods > NIC capacity

**Validation Criteria:**

* No payload storage
* No memory growth
* Backpressure engaged
* Core remains unaffected
* Audit logs present

**FAIL IF:**

* DPI crashes
* Silent drops occur
* Core ingestion stalls

---

## ğŸ”´ RT-02: DPI EVENT SPOOFING

**Goal:**
Inject forged DPI metadata events.

**Attack Simulation:**

* Replay valid event envelopes
* Modify fields post-signature
* Forge producer IDs

**Expected Outcome:**

* Signature verification fails
* Events rejected
* Replay detected
* No Core state change

---

## ğŸ”´ RT-03: AGENT IDENTITY TAKEOVER

**Goal:**
Impersonate Linux/Windows Agent.

**Attack Simulation:**

* Copy agent cert
* Modify agent binary
* Replay enforcement ACKs

**Expected Outcome:**

* Identity revocation
* Execution refusal
* Audit log
* No enforcement

---

# PLAYBOOK GROUP B â€” INGESTION & STREAMING

---

## ğŸ”´ RT-04: INGESTION BACKPRESSURE COLLAPSE

**Goal:**
Overflow ingestion buffers.

**Attack Simulation:**

* Burst telemetry from 10k agents
* Schema-valid but high-rate
* Slow Core downstream

**Expected Outcome:**

* Bounded buffers
* Deterministic rejection
* No memory exhaustion
* No silent drops

---

## ğŸ”´ RT-05: EVENT REORDERING & GAPS

**Goal:**
Break temporal correlation assumptions.

**Attack Simulation:**

* Reordered sequences
* Missing sequence numbers
* Clock skew injection

**Expected Outcome:**

* Explicit reordering handling
* No false detection
* Confidence decay applied
* Audit entries recorded

---

# PLAYBOOK GROUP C â€” CORE CORRELATION

---

## ğŸ”´ RT-06: KILL-CHAIN SKIP ATTACK

**Goal:**
Trigger late-stage ransomware detection without early signals.

**Attack Simulation:**

* Emit encryption-like telemetry
* Skip lateral movement & privilege escalation signals

**Expected Outcome:**

* Invariant violation
* Detection refused
* No policy trigger

---

## ğŸ”´ RT-07: ENTITY EXPLOSION ATTACK

**Goal:**
Exhaust Core memory with fake entities.

**Attack Simulation:**

* Random host/process IDs
* High churn identity creation

**Expected Outcome:**

* Eviction strategy applied
* Memory bounded
* Core survives
* Detection accuracy preserved

---

## ğŸ”´ RT-08: NON-DETERMINISM PROBE

**Goal:**
Force different outcomes from same input.

**Attack Simulation:**

* Replay identical event streams
* Alter thread timing
* Change arrival order

**Expected Outcome:**

* Identical outputs
* Identical confidence
* Identical explainability

---

# PLAYBOOK GROUP D â€” POLICY & ENFORCEMENT

---

## ğŸ”´ RT-09: POLICY CONFLICT AMBIGUITY

**Goal:**
Force ambiguous enforcement.

**Attack Simulation:**

* Two signed policies with overlapping scope
* Opposing actions

**Expected Outcome:**

* Conflict detected
* No enforcement
* Audit entry

---

## ğŸ”´ RT-10: UNSIGNED POLICY INJECTION

**Goal:**
Execute enforcement without valid policy.

**Attack Simulation:**

* Inject unsigned policy
* Expired signature
* Revoked key

**Expected Outcome:**

* Policy rejected
* Enforcement blocked
* Alert logged

---

## ğŸ”´ RT-11: ROLLBACK FAILURE ATTACK

**Goal:**
Cause partial enforcement without rollback.

**Attack Simulation:**

* Kill agent mid-execution
* Network drop after action
* ACK suppression

**Expected Outcome:**

* Rollback initiated
* Partial state reversed
* No repeated harm

---

# PLAYBOOK GROUP E â€” AI / ML / LLM ATTACKS

---

## ğŸ”´ RT-12: AI POISONING ATTEMPT

**Goal:**
Influence detection via AI.

**Attack Simulation:**

* Feed misleading telemetry
* Try to bias AI confidence

**Expected Outcome:**

* AI advisory only
* Core unaffected
* AI confidence bounded
* No enforcement change

---

## ğŸ”´ RT-13: SHAP SUPPRESSION

**Goal:**
Force inference without explainability.

**Attack Simulation:**

* Corrupt SHAP artifact
* Remove SHAP baseline

**Expected Outcome:**

* AI inference blocked
* Core unaffected
* Audit log present

---

## ğŸ”´ RT-14: LLM HALLUCINATION TEST

**Goal:**
Force LLM to suggest enforcement.

**Attack Simulation:**

* Prompt injection
* Leading analyst queries

**Expected Outcome:**

* Guardrails block
* Advisory language only
* No action suggestion

---

# PLAYBOOK GROUP F â€” FORENSICS & REPORTING

---

## ğŸ”´ RT-15: EVIDENCE TAMPERING

**Goal:**
Modify stored evidence.

**Attack Simulation:**

* Alter CSV rows
* Edit PDF metadata
* Change timestamps

**Expected Outcome:**

* Hash mismatch detected
* Verification fails
* Evidence invalidated visibly

---

## ğŸ”´ RT-16: CHAIN-OF-CUSTODY BREAK

**Goal:**
Hide access or export.

**Attack Simulation:**

* Access evidence without logging
* Delete custody entry

**Expected Outcome:**

* Access blocked
* Audit alert
* Custody remains intact

---

# PLAYBOOK GROUP G â€” INSTALLER & OPS

---

## ğŸ”´ RT-17: EULA BYPASS

**Goal:**
Install without EULA acceptance.

**Attack Simulation:**

* Non-interactive install
* Scripted bypass

**Expected Outcome:**

* Install aborted
* No services installed

---

## ğŸ”´ RT-18: SWAP REMOVAL ATTACK

**Goal:**
Run Core/DPI without swap.

**Attack Simulation:**

* Remove swap after install
* Boot Core

**Expected Outcome:**

* Startup failure
* Explicit error
* No degraded run

---

## ğŸ”´ RT-19: PARTIAL UPGRADE CORRUPTION

**Goal:**
Break version compatibility.

**Attack Simulation:**

* Interrupt upgrade mid-way
* Mix versions

**Expected Outcome:**

* Rollback executed
* System restored
* Audit recorded

---

# PLAYBOOK GROUP H â€” SCALE & BATTLEFIELD

---

## ğŸ”´ RT-20: FULL ENTERPRISE CAMPAIGN

**Goal:**
Simulate real ransomware across 50k endpoints.

**Attack Simulation:**

* Initial access â†’ lateral â†’ encryption
* Mixed OS
* Concurrent benign load

**Expected Outcome:**

* Correct kill-chain detection
* Controlled enforcement
* No collateral damage
* Complete forensic trail

---

# âœ… RED-TEAM SUCCESS CRITERIA

RansomEye PASSES if:

* No phase fails open
* No enforcement occurs on ambiguity
* AI never overrides logic
* Memory & CPU remain bounded
* All attacks are logged
* Recovery is deterministic
* Evidence is defensible

---


