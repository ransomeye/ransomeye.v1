PROMPT 4: SCALABLE INGESTION, DEDUPLICATION & NORMALIZATION
Goal: Build core/ingest. This module acts as the "Front Door" for all telemetry. It receives raw events from the Bus, Deduplicates them (preventing alert fatigue), Normalizes them into a standard schema, and forwards clean data to the Core Engine. Critical Scalability Logic:

Dynamic Cache Sizing: The Deduplication LRU Cache size must scale with available RAM. (Don't waste RAM on small boxes, don't thrash on big ones).

Adaptive Backpressure: If the Core is overloaded, the Ingest layer must drop low-priority logs (Info/Debug) to preserve high-priority alerts (Critical).

Target Path: /home/ransomeye/rebuild/core/ingest/

Dependencies: tokio, serde, serde_json, lru (for in-memory dedupe), sys-info (RAM detection), sha2 (hashing), tracing, quick-xml (fast Windows parsing).

1. SETUP
Initialize core/ingest as a Rust Library crate. Add dependencies: core/bus and core/kernel (config).

2. DIRECTORY STRUCTURE
Plaintext

core/ingest/
├── Cargo.toml
└── src/
    ├── lib.rs
    ├── pipeline.rs         # Main Event Loop (Async)
    ├── tuning.rs           # Dynamic Cache Sizing
    ├── dedupe.rs           # The Noise Filter (LRU)
    ├── normalization.rs    # Schema Mappers (Windows/Linux)
    └── rate_limit.rs       # Backpressure & Load Shedding
3. IMPLEMENTATION TASKS
A. Dynamic Tuning (src/tuning.rs)
Logic:

Get TotalRAM via sys_info.

Calculate Dedupe Capacity:

Small Profile (<8GB RAM): Cap at 50,000 items. (Keep footprint tiny).

Massive Profile (>64GB RAM): Cap at 2,000,000 items. (Absorb massive event storms from 50k agents).

Output: Return CacheConfig struct.

B. The Pipeline (src/pipeline.rs)
Logic:

Subscribe to telemetry.* and logs.* on the Bus.

Step 1: Rate Limit: Pass through rate_limit::check(). If it returns Drop, discard immediately.

Step 2: Dedupe: Pass through dedupe::should_process(). If false, discard.

Step 3: Normalize: Pass through normalization::normalize().

Step 4: Publish: Send result to core.normalized_events topic.

C. The Deduplication Engine (src/dedupe.rs)
Goal: Stop "Flapping" alerts (e.g., a service restarting 100 times/min).

Structure: Use lru::LruCache wrapped in a RwLock.

Initialization: LruCache::new(tuning::get_capacity()).

Algorithm (Exact Dedupe):

Extract (source_ip, event_type, target_process).

Compute Hash = SHA256(concat(fields)).

Check Cache:

If Hash exists and last_seen < 60s: DROP and increment a suppressed_count metric.

If new or expired: UPDATE cache and PASS.

Output: Returns bool (process or drop).

D. Adaptive Rate Limiting (src/rate_limit.rs)
Goal: Protect the DB/Core from 50k agents sending logs simultaneously.

Logic:

Monitor ChannelCapacity (Queue depth to Core).

Normal Mode: Pass all events.

Panic Mode (Queue > 80% full):

DROP all Info and Debug logs immediately.

PASS only Warning and Critical alerts.

Log a LoadSheddingActive meta-event once per minute.

E. Normalization (src/normalization.rs)
Input: RawTelemetry (JSON/Protobuf with arbitrary fields).

Output: StandardEvent struct.

Rust

pub struct StandardEvent {
    pub timestamp: i64,
    pub host_id: String,
    pub event_type: EventType, // Enum: ProcessStart, NetConnect, FileWrite
    pub subject: String,       // e.g., "powershell.exe"
    pub object: String,        // e.g., "C:\Users\Admin\passwords.txt"
    pub raw_source: String,    // Original log for evidence
}
Mappers:

from_windows_xml(): Parse EventID 4688 (Process Creation).

from_linux_audit(): Parse type=EXECVE or type=SYSCALL.

4. ACCEPTANCE CRITERIA
Scaling Test: On a 196GB RAM mock, the LRU Cache initializes with capacity > 1 Million items.

Dedupe Test: Sending 100 identical events results in exactly 1 event passed to normalization.

Load Shedding: When the output channel is flooded (mocked to 80%), "Info" logs are dropped, but "Ransomware Detected" alerts still pass through.

Normalization Test: A raw Windows XML log for cmd.exe is correctly converted into a StandardEvent with event_type: ProcessStart.