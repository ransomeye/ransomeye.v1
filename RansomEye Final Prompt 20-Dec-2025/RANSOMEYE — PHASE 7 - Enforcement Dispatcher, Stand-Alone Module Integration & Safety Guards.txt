# ğŸšš RANSOMEYE â€” PHASE 7

## Enforcement Dispatcher, Stand-Alone Module Integration & Safety Guards

### **(AUTHORITATIVE MASTER PROMPT â€“ PHASE 7)**

**Environment Root:** `/home/ransomeye/rebuild/`
**Phase Folder:** `/home/ransomeye/rebuild/ransomeye_dispatcher/`

---

## CONTEXT (CRITICAL SAFETY LAYER)

This phase is the **only bridge** between:

* **Authoritative policy decisions (Phase 6)**
  and
* **Stand-alone executors**:

  * DPI Probe
  * Linux Agent
  * Windows Agent

This layer **does not decide**, **does not infer**, and **does not enforce locally**.

It **only transports**, **verifies**, **tracks**, and **confirms** enforcement actions.

Any mistake here can:

* Execute the wrong action
* Execute on the wrong host
* Execute without rollback
* Execute without audit

This phase must therefore be **extremely strict and conservative**.

---

## ğŸš¨ GLOBAL RULES (RE-ENFORCED)

All rules from **Phase 1â€“6** apply unchanged.

Additional Phase-7 rules below are **hard enforcement**.

---

## ğŸ¯ PHASE 7 OBJECTIVE

Build a **deterministic, cryptographically enforced Enforcement Dispatcher** that:

1. Accepts **only signed directives** from Phase 6
2. Validates scope, TTL, and preconditions
3. Delivers directives to correct stand-alone modules
4. Enforces execution acknowledgment
5. Enforces rollback if execution fails
6. Maintains end-to-end auditability
7. Never executes enforcement itself

---

## ğŸ“¦ RESPONSIBILITY BOUNDARIES (STRICT)

### MUST DO

* Directive verification
* Target resolution
* Secure delivery
* Execution tracking
* Acknowledgment verification
* Timeout handling
* Rollback coordination
* Audit logging

### MUST NEVER DO

* Modify directives
* Re-interpret policy
* Execute enforcement locally
* Retry blindly
* Trust agents implicitly

---

## ğŸ“ PHASE 7 DIRECTORY STRUCTURE (MANDATORY)

Create exactly:

```
/home/ransomeye/rebuild/ransomeye_dispatcher/
```

```
ransomeye_dispatcher/
â”œâ”€â”€ dispatcher/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ dispatcher.rs
â”‚   â”‚   â”œâ”€â”€ verifier.rs
â”‚   â”‚   â”œâ”€â”€ router.rs
â”‚   â”‚   â”œâ”€â”€ delivery.rs
â”‚   â”‚   â”œâ”€â”€ acknowledgment.rs
â”‚   â”‚   â”œâ”€â”€ timeout.rs
â”‚   â”‚   â”œâ”€â”€ rollback.rs
â”‚   â”‚   â””â”€â”€ audit.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ dispatcher_errors.rs
â”‚
â”œâ”€â”€ protocol/
â”‚   â”œâ”€â”€ directive_envelope.rs
â”‚   â”œâ”€â”€ acknowledgment_schema.json
â”‚   â””â”€â”€ versioning.md
â”‚
â”œâ”€â”€ targets/
â”‚   â”œâ”€â”€ dpi.rs
â”‚   â”œâ”€â”€ linux_agent.rs
â”‚   â””â”€â”€ windows_agent.rs
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ signature.rs
â”‚   â”œâ”€â”€ trust_chain.rs
â”‚   â”œâ”€â”€ nonce.rs
â”‚   â””â”€â”€ replay_protection.rs
â”‚
â”œâ”€â”€ config/
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ dispatcher_flow.md
â”‚   â”œâ”€â”€ execution_guarantees.md
â”‚   â”œâ”€â”€ rollback_model.md
â”‚   â”œâ”€â”€ blast_radius.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ directive_validation_tests.rs
    â”œâ”€â”€ misrouting_tests.rs
    â”œâ”€â”€ timeout_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â””â”€â”€ replay_attack_tests.rs
```

---

## ğŸ” DIRECTIVE VERIFICATION (MANDATORY)

Before delivery, dispatcher MUST verify:

* Policy Engine signature
* Directive signature
* Directive TTL
* Target scope
* Preconditions hash
* Nonce freshness

Any failure â†’ **DO NOT DELIVER**

---

## ğŸ¯ TARGET RESOLUTION (STRICT)

Dispatcher MUST:

* Resolve exact target(s)
* Validate agent identity
* Validate agent capability
* Validate platform compatibility

If ambiguity exists â†’ **ABORT**

---

## ğŸ”„ DELIVERY & ACKNOWLEDGMENT FLOW

You MUST implement:

1. Directive verification
2. Target resolution
3. Secure delivery (mutual auth)
4. Agent execution
5. Signed acknowledgment
6. Result verification
7. Audit record append

Missing acknowledgment within TTL â†’ **ROLLBACK INITIATED**

---

## ğŸ§¯ ROLLBACK & SAFETY GUARDS

Rollback MUST:

* Be explicit
* Be signed
* Restore previous state
* Be auditable
* Be time-bounded

Rollback failure â†’ **ESCALATE + ALERT**

---

## ğŸ” AUDIT & TRACEABILITY

Dispatcher MUST maintain:

* Delivery receipts
* Execution acknowledgments
* Rollback records
* Hash-chained logs

All records must be:

* Append-only
* Signed
* Verifiable

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Invalid directives
* Agent unreachable
* Partial execution
* Timeout without acknowledgment
* Replay attempts
* Identity mismatch

Failures must:

* Preserve safety
* Avoid repeated harm
* Be observable

---

## ğŸ§ª VALIDATION REQUIREMENTS

You MUST include tests that:

* Deliver to wrong agent (must fail)
* Replay directives
* Corrupt acknowledgments
* Force rollback
* Exhaust retries

---

## ğŸ›‘ FAILURE CONDITIONS (HARD)

Phase 7 is INVALID if:

* Dispatcher executes enforcement
* Unsigned directives are delivered
* Rollback is optional
* Target ambiguity is tolerated
* Acknowledgment is best-effort

---

## FINAL INSTRUCTION

Treat Phase 7 as:

* A **weapons safety system**
* A **dead-man switch**
* A **blast-radius governor**

If Phase 7 fails, **RansomEye becomes dangerous**.

**BUILD PHASE 7 COMPLETELY, EXPLICITLY, AND WITHOUT ASSUMPTIONS.**

---
