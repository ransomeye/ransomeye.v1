# ğŸ” RANSOMEYE â€“ PHASE 2

## Configuration, Secrets, Identity & Cryptographic Trust Foundation

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (NON-NEGOTIABLE)

You are continuing the **from-scratch rebuild of RansomEye**.

* Phase 0 enforced governance, licensing, CI, and signing rules
* Phase 1 defined binding architecture, data flow, and trust boundaries

**Phase 2 establishes identity, secrets, cryptographic trust, and startup enforcement.**

If Phase 2 is weak:

* Any attacker can impersonate components
* Any misconfiguration can silently degrade security
* Fail-open behavior becomes possible

This phase is **SECURITY-CRITICAL**.

---

## ğŸš¨ GLOBAL HARD RULES (ABSOLUTE)

These rules are inherited and MUST be enforced again:

* ENV-only configuration (no exceptions)
* No hardcoded values (IP, ports, paths, credentials, secrets)
* Missing or invalid config = **FAIL CLOSED**
* Mandatory file headers
* Linux-agnostic
* Static binaries preferred
* No GPL / AGPL / unknown licenses
* No assumptions
* Cryptographic verification required at boundaries

---

## ğŸ¯ PHASE 2 OBJECTIVE

Build a **unified, cryptographically enforced configuration and identity system** that:

1. Ensures every component has a **verifiable identity**
2. Ensures every secret is **validated before startup**
3. Enforces **fail-closed startup**
4. Prevents **implicit trust**
5. Enables **secure rotation and revocation**

This phase produces **shared primitives** used by *every* later phase.

---

## ğŸ“¦ REQUIRED DELIVERABLES (ALL MANDATORY)

---

## 1ï¸âƒ£ GLOBAL ENVIRONMENT VARIABLE SCHEMA

You MUST define a **strict environment schema** covering:

### Categories (MANDATORY)

* Core
* DPI Probe
* Agents
* AI / ML
* Control Plane
* Cryptography
* Signing & Verification
* Storage
* Networking
* Feature Flags (explicit, validated)

### Requirements

* No default secret values
* Type validation (string, int, bool, path)
* Required vs optional clearly marked
* Optional values must still be validated if present
* Unknown env vars must be flagged

### Required File

```
.env.example
```

â¡ï¸ This file contains **names, descriptions, types â€” NEVER values**

---

## 2ï¸âƒ£ CONFIGURATION VALIDATION ENGINE (FAIL-CLOSED)

You MUST design and implement a **configuration validation engine**.

### Requirements

* Runs before application startup
* Blocks execution if:

  * Required env missing
  * Invalid type
  * Weak crypto parameters
  * Unknown / unsupported options
* Produces **explicit error messages**
* Zero tolerance for silent fallback

### Language

* Rust (primary)
* Python wrapper allowed for AI layer only

---

## 3ï¸âƒ£ CRYPTOGRAPHIC IDENTITY MODEL (CORE, DPI, AGENTS)

You MUST define identities for:

* Core
* DPI Probes
* Linux Agents
* Windows Agents
* Control Plane
* AI Subsystems (read-only identity)

### Identity Requirements

* Unique per instance
* Cryptographically verifiable
* Rotatable
* Revocable
* Never hardcoded
* Stored securely (no plaintext on disk)

### Deliverables

* Identity lifecycle design
* Key generation flow
* Enrollment flow
* Revocation flow

---

## 4ï¸âƒ£ TRUST BOOTSTRAP & ATTESTATION

You MUST define:

* How a new component joins RansomEye
* How it proves identity
* How it is trusted (or rejected)
* How trust expires or is revoked

### Mandatory Concepts

* Mutual authentication
* Explicit trust chains
* No implicit trust
* Fail-closed on attestation failure

---

## 5ï¸âƒ£ SIGNING & VERIFICATION PRIMITIVES

This phase MUST implement shared primitives for:

* Artifact signing
* Policy signing
* Model signing
* Rule signing
* Config integrity verification

### Requirements

* Modern cryptography only
* Algorithm agility
* Signature verification before use
* Verification failure = **BLOCK OPERATION**

---

## ğŸ“ PHASE 2 FOLDER STRUCTURE (MANDATORY)

You MUST define and explain this structure:

```
security/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ env_schema.md
â”‚   â”œâ”€â”€ validator.rs
â”‚   â””â”€â”€ errors.rs
â”‚
â”œâ”€â”€ identity/
â”‚   â”œâ”€â”€ identity_model.md
â”‚   â”œâ”€â”€ key_management.md
â”‚   â”œâ”€â”€ enrollment_flow.md
â”‚   â”œâ”€â”€ revocation_flow.md
â”‚   â””â”€â”€ attestation.md
â”‚
â”œâ”€â”€ crypto/
â”‚   â”œâ”€â”€ algorithms.md
â”‚   â”œâ”€â”€ signing.rs
â”‚   â”œâ”€â”€ verification.rs
â”‚   â””â”€â”€ rotation.rs
â”‚
â”œâ”€â”€ bootstrap/
â”‚   â”œâ”€â”€ startup_sequence.md
â”‚   â”œâ”€â”€ trust_bootstrap.md
â”‚   â””â”€â”€ failure_modes.md
```

You MUST explain:

* Why each file exists
* What it enforces
* What it explicitly forbids

---

## ğŸ” TRUST BOUNDARY ENFORCEMENT (MANDATORY)

You MUST explicitly show how Phase 2 enforces trust boundaries defined in Phase 1:

* DPI â†’ Core
* Agent â†’ Core
* Control Plane â†’ Core
* AI â†’ Core (read-only, no authority)

Each boundary must include:

* Identity verification
* Signature verification
* Failure behavior

---

## ğŸ’¥ FAILURE BEHAVIOR (FAIL-CLOSED MATRIX)

You MUST define a **fail-closed matrix**:

| Condition           | Component | Behavior        |
| ------------------- | --------- | --------------- |
| Missing env var     | Any       | Refuse startup  |
| Invalid signature   | Any       | Block operation |
| Expired identity    | Any       | Disconnect      |
| Unknown config      | Any       | Refuse startup  |
| Attestation failure | Any       | Quarantine      |

No soft failures allowed.

---

## ğŸ§ª TESTING REQUIREMENTS (MANDATORY)

You MUST define:

* Synthetic config tests
* Identity spoofing tests
* Expired key tests
* Revocation tests
* Misconfiguration tests

No real secrets may be used.

---

## ğŸ“¤ EXPECTED OUTPUT FORMAT

You must output:

1. Environment schema documentation
2. Configuration validation design
3. Identity & trust architecture
4. Folder structure explanation
5. Signing & verification primitives
6. Failure matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Any config is optional without validation
* Any identity is implicitly trusted
* Any failure degrades to warning
* Any secret has a default
* Any component can start partially trusted

---

## FINAL INSTRUCTION

This phase is the **root of trust** for RansomEye.

Design it as if:

* An attacker controls the network
* An operator misconfigures the system
* A component is compromised

**FAIL CLOSED. VERIFY EVERYTHING. TRUST NOTHING.**

**BUILD PHASE 2 COMPLETELY AND EXPLICITLY.**
