# ğŸ›¡ï¸ RANSOMEYE â€“ PHASE 6

## Policy Engine, Decision Validation & Fail-Closed Enforcement

### **(PROMPT NUMBER 6 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (SECURITY-CRITICAL)

You are now building the **Policy Engine** of RansomEye.

This phase is where **decisions become actions** â€” therefore **this is the highest-risk phase** from a security, correctness, and legal standpoint.

If this phase is wrong:

* RansomEye may block incorrectly
* Or fail to block when required
* Or become non-deterministic
* Or violate zero-trust guarantees

This phase **must be strictly deterministic, auditable, and fail-closed**.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Any GC-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

* GPL / AGPL / SSPL â†’ **BANNED**
* Unknown licenses â†’ **BANNED**

Allowed only:

* MIT
* BSD
* Apache 2.0

---

## ğŸ¯ PHASE 6 OBJECTIVE

Build a **cryptographically enforced, deterministic Policy Engine** that:

1. Receives correlation results from Phase 5
2. Validates decision integrity
3. Evaluates signed policies
4. Produces **explicit enforcement directives**
5. Fails closed on ambiguity or error

This engine:

* **Does enforce policy**
* **Does NOT perform correlation**
* **Does NOT invoke AI**
* **Does NOT guess**

---

## ğŸ“¦ POLICY ENGINE RESPONSIBILITIES (STRICT)

### MUST DO

* Load only **signed policies**
* Validate policy schema and version
* Evaluate rules deterministically
* Enforce precedence and conflict resolution
* Produce enforcement directives
* Generate full audit trail

### MUST NEVER DO

* Modify correlation results
* Trust unsigned input
* Perform probabilistic decisions
* Auto-correct malformed policies
* Continue execution on uncertainty

---

## ğŸ“ PHASE 6 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
core/
â”œâ”€â”€ policy/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ engine.rs
â”‚   â”‚   â”œâ”€â”€ evaluator.rs
â”‚   â”‚   â”œâ”€â”€ precedence.rs
â”‚   â”‚   â”œâ”€â”€ conflict.rs
â”‚   â”‚   â”œâ”€â”€ enforcement.rs
â”‚   â”‚   â””â”€â”€ audit.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ policy_schema.rs
â”‚   â”‚   â”œâ”€â”€ validation.rs
â”‚   â”‚   â””â”€â”€ versioning.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ signature.rs
â”‚   â”‚   â”œâ”€â”€ verification.rs
â”‚   â”‚   â””â”€â”€ trust_chain.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ enforcement_directive.rs
â”‚   â”‚   â””â”€â”€ audit_record.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ policy_errors.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ policy_language.md
â”‚   â”œâ”€â”€ evaluation_model.md
â”‚   â”œâ”€â”€ conflict_resolution.md
â”‚   â”œâ”€â”€ enforcement_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ signed_policy_tests.rs
    â”œâ”€â”€ conflict_tests.rs
    â”œâ”€â”€ precedence_tests.rs
    â”œâ”€â”€ failure_tests.rs
    â””â”€â”€ audit_tests.rs
```

---

## ğŸ“œ POLICY LANGUAGE (MANDATORY DESIGN)

You MUST define:

* Explicit policy syntax
* Versioning rules
* Deterministic evaluation order
* Conflict resolution rules
* Safe defaults (fail-closed)

No dynamic code execution.
No embedded scripts.
No user-defined functions.

---

## ğŸ” SIGNING & TRUST (MANDATORY)

Policies:

* MUST be cryptographically signed
* MUST include metadata:

  * Author
  * Version
  * Validity window
  * Scope

Policy Engine MUST:

* Verify signature
* Verify trust chain
* Verify expiration
* Reject unsigned or expired policies

---

## ğŸ”€ EVALUATION PIPELINE (STEP-BY-STEP)

You MUST explicitly define:

1. Input validation
2. Signature verification
3. Schema validation
4. Version compatibility
5. Rule evaluation
6. Conflict resolution
7. Enforcement decision generation
8. Audit record creation
9. Output dispatch

Each step must include:

* Input
* Output
* Failure behavior

---

## âš™ï¸ ENFORCEMENT DIRECTIVES

You MUST define:

* Directive types (block, isolate, alert, monitor, etc.)
* Target scope
* Expiration
* Rollback behavior
* Idempotency guarantees

---

## ğŸ’¥ FAILURE MODES (FAIL-CLOSED MATRIX)

Define behavior for:

* Missing policy
* Invalid signature
* Conflicting rules
* Unsupported version
* Internal errors
* Resource exhaustion

**All must block or degrade safely â€” never allow silently.**

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Signed vs unsigned policy tests
* Conflict resolution tests
* Regression tests
* Determinism verification
* Audit integrity tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Policy engine architecture
2. Folder structure explanation
3. Policy language specification
4. Evaluation pipeline
5. Enforcement model
6. Audit & compliance design
7. Failure handling matrix
8. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python appears anywhere
* Unsigned policies are accepted
* Evaluation order is implicit
* Conflicts are auto-resolved silently
* Fail-open behavior exists
* Enforcement is ambiguous

---

## FINAL INSTRUCTION

This phase is the **point of no return**.

Design it as if:

* Policies are written by humans
* Humans make mistakes
* Attackers attempt policy poisoning

**VERIFY EVERYTHING. FAIL CLOSED. EXECUTE NOTHING ON TRUST.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 6 OF 12**

