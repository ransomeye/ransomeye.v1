# ğŸš€ RANSOMEYE â€“ PHASE 3

## DPI PROBE (DATA PLANE) â€” HIGH-THROUGHPUT PACKET PROCESSING

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (CRITICAL â€“ READ FIRST)

You are building the **RansomEye DPI Probe**, which is the **highest-risk and highest-performance component** in the entire platform.

This component must reliably process **40+ Gbps sustained traffic**, across **multiple probes**, without packet loss, license risk, or unpredictable latency.

Any mistake here will:

* Break scale guarantees
* Introduce GPL contamination
* Cause packet drops
* Create latency spikes
* Make RansomEye unsellable

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES (NON-NEGOTIABLE)

### âœ… ALLOWED LANGUAGES

* **Rust (PRIMARY, REQUIRED)**
* **C++ (SECONDARY, ONLY where strictly necessary)**
* **eBPF (kernel space only)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Scapy
* Any interpreted or GC-based language

â¡ï¸ **Any use of forbidden languages = INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

* GPL / AGPL / SSPL â†’ **BANNED**
* Scapy â†’ **BANNED**
* Unknown license â†’ **BANNED**
* YARA rules â†’ **NOT USED in DPI**

Allowed:

* libpcap (BSD)
* AF_XDP
* Hyperscan (BSD)
* Rust crates (MIT / Apache / BSD only)

---

## ğŸ¯ PHASE 3 OBJECTIVE

Build a **GPL-free, Linux-agnostic, ultra-high-performance DPI Probe** that:

1. Captures packets at line rate
2. Reconstructs flows
3. Extracts metadata (NOT decisions)
4. Performs **NO policy enforcement**
5. Performs **NO AI inference**
6. Streams structured events to RansomEye Core

The DPI Probe is a **sensor**, not a brain.

---

## ğŸ“¦ DPI PROBE RESPONSIBILITIES (EXPLICIT)

### MUST DO

* Packet capture
* Flow tracking
* Session reconstruction
* TLS fingerprint extraction
* Metadata normalization
* Secure event streaming
* Backpressure handling

### MUST NEVER DO

* Policy decisions
* Blocking traffic
* AI inference
* Writing to databases
* Storing long-term state
* Trusting upstream components

---

## ğŸ“ PHASE 3 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain the following structure:

```
dpi_probe/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ capture/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ pcap.rs
â”‚   â”‚   â”œâ”€â”€ af_xdp.rs
â”‚   â”‚   â””â”€â”€ interface.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ pipeline/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ packet_decoder.rs
â”‚   â”‚   â”œâ”€â”€ flow_tracker.rs
â”‚   â”‚   â”œâ”€â”€ session_reassembly.rs
â”‚   â”‚   â””â”€â”€ metadata_extractor.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ threading/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ cpu_pinning.rs
â”‚   â”‚   â”œâ”€â”€ numa.rs
â”‚   â”‚   â””â”€â”€ backpressure.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ event_schema.rs
â”‚   â”‚   â”œâ”€â”€ serializer.rs
â”‚   â”‚   â””â”€â”€ secure_stream.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ attestation.rs
â”‚   â”‚   â””â”€â”€ verification.rs
â”‚
â”œâ”€â”€ ebpf/
â”‚   â”œâ”€â”€ xdp_program.c
â”‚   â”œâ”€â”€ maps.h
â”‚   â””â”€â”€ loader.rs
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ env_schema.md
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ packet_pipeline.md
â”‚   â”œâ”€â”€ threading_model.md
â”‚   â”œâ”€â”€ memory_model.md
â”‚   â”œâ”€â”€ failure_modes.md
â”‚   â””â”€â”€ performance_targets.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_packets.rs
    â”œâ”€â”€ throughput_tests.rs
    â””â”€â”€ failure_tests.rs
```

---

## âš™ï¸ PERFORMANCE & THREADING MODEL (MANDATORY)

You MUST define:

* Per-CPU worker model
* Thread pinning strategy
* NUMA locality handling
* Lock-free queues
* Zero-copy buffers
* Memory pool reuse
* Backpressure behavior

ğŸš« DO NOT:

* Assume swap = RAM
* Allocate per packet
* Use global locks

---

## ğŸ”€ PACKET PIPELINE (STEP-BY-STEP)

You MUST explicitly define:

1. NIC â†’ Kernel
2. Kernel â†’ Userland (AF_XDP / libpcap)
3. Packet decode
4. Flow tracking
5. Session reassembly
6. Metadata extraction
7. Event serialization
8. Secure transmission to Core

Each step must include:

* Input
* Output
* Failure behavior
* Performance impact

---

## ğŸ” SECURITY & TRUST (ENFORCED)

* DPI Probe must have its own cryptographic identity
* Mutual authentication with Core
* No implicit trust
* Attestation before streaming events
* Fail-closed if Core verification fails

---

## ğŸ’¥ FAILURE MODES (REQUIRED)

Define behavior for:

* Packet overload
* CPU starvation
* Memory exhaustion
* Network disconnect
* Identity expiration
* Signature verification failure

All must be **fail-safe and observable**.

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic packet generators
* Throughput benchmarks
* Backpressure tests
* Crash recovery tests
* Identity spoofing tests

No real traffic captures allowed.

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. DPI Probe architecture explanation
2. Folder structure explanation
3. Threading & memory model
4. Packet pipeline walkthrough
5. Security enforcement design
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python is used anywhere
* Scapy is referenced
* Policy logic exists
* AI logic exists
* Packet blocking exists
* GPL components appear

---

## FINAL INSTRUCTION

Treat this as a **carrier-grade DPI system**, not a prototype.

Assume:

* Hostile traffic
* Hostile network
* Extreme scale
* Continuous operation

**BUILD PHASE 3 COMPLETELY, STRICTLY, AND WITHOUT SHORTCUTS.**
