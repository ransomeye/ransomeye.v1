# ğŸ”’ RANSOMEYE â€“ PHASE 0

## Governance, Licensing, Repository & Build Enforcement Foundation

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (READ CAREFULLY)

You are building **RansomEye from absolute scratch** as a **commercial, closed-source, enterprise-grade cybersecurity platform**.

RansomEye **will be sold commercially**, therefore:

* **NO source code disclosure is allowed**
* **NO copyleft contamination is allowed**
* **NO GPL / AGPL / unknown licenses are allowed**
* **NO assumptions are allowed**

This phase establishes **non-negotiable guardrails**.
If Phase 0 is weak, the entire product becomes legally and technically invalid.

---

## ğŸš¨ GLOBAL HARD RULES (APPLY EVERYWHERE)

You MUST enforce ALL of the following:

### 1. License Rules (FAIL CLOSED)

**Allowed only**

* MIT
* BSD 2-Clause / 3-Clause
* Apache 2.0
* PSF
* CC0

**Conditionally allowed**

* LGPL â†’ **ONLY if dynamically linked, isolated, and replaceable**

**BANNED (ABSOLUTE)**

* GPL v2 / v3
* AGPL
* SSPL
* Elastic License
* Any â€œcustomâ€, â€œunknownâ€, or unclear license
* GPL rule packs or content (even if engine is permissive)

â¡ï¸ **CI must fail immediately if a banned license is detected**

---

### 2. Configuration Rules

* **ENV-only configuration**
* No hardcoded:

  * IPs
  * Hostnames
  * Ports
  * Paths
  * Credentials
  * Secrets
* No defaults for secrets
* Missing env vars = **FAIL CLOSED**

---

### 3. File & Code Rules

* Every file MUST start with a mandatory header:

  * File path
  * Author ID
  * Purpose / Details
* Applies to:

  * `.rs .c .cpp .py .sh .yaml .json .toml .service`
* No placeholder logic
* No TODO-only implementations

---

### 4. Data Rules

* **NO sample or dummy datasets committed**
* Tests must generate **synthetic data at runtime only**
* No training data stored in repo

---

### 5. Security Rules

* Artifact signing is mandatory:

  * Code
  * Binaries
  * Models
  * Rules
* Verification must exist at runtime
* Fail-closed on verification failure

---

## ğŸ¯ PHASE 0 OBJECTIVE

Build the **legal, structural, and enforcement foundation** that every future phase depends on.

This phase produces **NO business logic**, but it **controls everything** that follows.

---

## ğŸ“¦ REQUIRED DELIVERABLES (ALL MANDATORY)

### A. Repository Folder Structure (FINAL)

You MUST create and document the following **top-level repository structure**:

```
ransomeye/
â”œâ”€â”€ governance/
â”‚   â”œâ”€â”€ LICENSE_POLICY.md
â”‚   â”œâ”€â”€ THIRD_PARTY_POLICY.md
â”‚   â”œâ”€â”€ SECURITY_POLICY.md
â”‚   â”œâ”€â”€ CODE_SIGNING_POLICY.md
â”‚   â””â”€â”€ CONTRIBUTION_RULES.md
â”‚
â”œâ”€â”€ build/
â”‚   â”œâ”€â”€ ci/
â”‚   â”‚   â”œâ”€â”€ license_scan.yml
â”‚   â”‚   â”œâ”€â”€ secret_scan.yml
â”‚   â”‚   â”œâ”€â”€ header_enforcement.yml
â”‚   â”‚   â””â”€â”€ artifact_signing.yml
â”‚   â”‚
â”‚   â”œâ”€â”€ tooling/
â”‚   â”‚   â”œâ”€â”€ license_validator.py
â”‚   â”‚   â”œâ”€â”€ header_validator.py
â”‚   â”‚   â”œâ”€â”€ secret_validator.py
â”‚   â”‚   â””â”€â”€ artifact_signer.py
â”‚
â”œâ”€â”€ core/                # Rust â€“ created later
â”œâ”€â”€ dpi_probe/           # Rust/C++ â€“ created later
â”œâ”€â”€ agents/              # Rust â€“ created later
â”œâ”€â”€ ai/                  # Python â€“ created later
â”œâ”€â”€ control_plane/       # Rust/Go â€“ created later
â”œâ”€â”€ frontend/            # React â€“ created later
â”‚
â”œâ”€â”€ installers/
â”‚   â”œâ”€â”€ unified_installer/
â”‚   â””â”€â”€ systemd/
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ operations/
â”‚   â”œâ”€â”€ security/
â”‚   â””â”€â”€ compliance/
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ bootstrap.sh
â”‚   â”œâ”€â”€ verify_repo.sh
â”‚   â””â”€â”€ airgap_prepare.sh
â”‚
â”œâ”€â”€ .env.example         # NO secrets, schema only
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md
â””â”€â”€ VERSION
```

You must **explain the purpose of every folder**.

---

### B. License Governance (CRITICAL)

Produce:

1. **LICENSE_POLICY.md**

   * Explicit allowlist
   * Explicit denylist
   * Rationale
   * Enforcement rules

2. **THIRD_PARTY_POLICY.md**

   * How libraries are approved
   * How replacements are handled
   * How upgrades are reviewed

3. **Automated License Scanner**

   * Python or Rust tool
   * Scans:

     * Python deps
     * Rust crates
     * System libraries (where possible)
   * Fails CI on violation

---

### C. Mandatory File Header Specification

Define a **single mandatory header format**, for example:

```
# Path: ransomeye/core/engine/main.rs
# Author: RansomEye Core Team
# Details: Core correlation engine entrypoint
```

Requirements:

* Header validator must enforce this
* CI must fail if header missing or malformed

---

### D. Secret & ENV Validation Framework

Deliver:

* `.env.example` schema (NO values)
* Secret validator logic:

  * Required vars
  * Type validation
  * Fail-closed startup
* CI check for accidental secrets

---

### E. Artifact Signing & Verification Design

You MUST design:

* Signing workflow
* Key hierarchy
* Verification points

Artifacts to sign:

* Binaries
* Packages
* Models
* Rules
* Policies

Deliverables:

* CODE_SIGNING_POLICY.md
* Signing flow diagram (textual)
* Example signing + verification logic

---

### F. CI Enforcement Pipelines

Provide **example CI YAMLs** for:

1. License scanning
2. Header enforcement
3. Secret detection
4. Artifact signing validation

Each pipeline MUST:

* Fail fast
* Produce explicit error messages
* Block merge on violation

---

## â›” ABSOLUTE CONSTRAINTS

* Do NOT write business logic
* Do NOT skip any deliverable
* Do NOT assume future phases will â€œfix itâ€
* Do NOT weaken enforcement for convenience
* Do NOT include GPL examples â€œfor referenceâ€

---

## ğŸ“¤ EXPECTED OUTPUT FORMAT

You must output:

1. Folder structure explanation
2. All governance documents (Markdown)
3. CI YAML examples
4. Validation tool designs (pseudo-code or real code)
5. Clear explanation of enforcement flow

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Any banned license is tolerated
* Any rule is â€œrecommendedâ€ instead of enforced
* Any secret has a default
* Any file header rule is optional
* Any placeholder logic is used

---

## FINAL INSTRUCTION

This phase is **FOUNDATIONAL**.

Treat this like:

* A military compliance framework
* A bank-grade governance system
* A legal contract enforced by code

**BUILD PHASE 0 COMPLETELY AND EXPLICITLY.**

---

# ğŸ§  RANSOMEYE â€“ PHASE 1

## System Architecture, Data Flow & Trust Boundary Design

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (NON-NEGOTIABLE)

You are continuing the **ground-up rebuild of RansomEye**.

Phase 0 established **legal, security, and governance enforcement**.
Phase 1 defines **how the entire system works before a single functional line of code is written**.

This phase is **pure architecture** â€” but it must be **implementation-aware** and **scale-accurate**.

RansomEye must support:

* **50,000+ endpoints**
* **Multiple DPI Probes**
* **Sustained 40+ Gbps traffic**
* **Air-gapped deployments**
* **Fail-closed security posture**
* **Commercial closed-source distribution**

---

## ğŸš¨ GLOBAL HARD RULES (REPEAT & ENFORCE)

These rules are inherited from Phase 0 and **cannot be weakened**:

* GPL / AGPL / unknown licenses are banned
* ENV-only configuration
* Mandatory file headers everywhere
* No Python on hot path
* No assumptions
* Linux-agnostic design
* Static binaries preferred
* Fail-closed on uncertainty
* No sample data
* AI is advisory unless explicitly stated otherwise

---

## ğŸ¯ PHASE 1 OBJECTIVE

Define a **complete, enforceable, phase-accurate system architecture** that:

1. Clearly separates **data plane vs control plane**
2. Defines **trust boundaries**
3. Defines **responsibility of each component**
4. Defines **data contracts and flows**
5. Prevents architectural drift in later phases

This architecture will be treated as **binding** for all later phases.

---

## ğŸ“¦ REQUIRED ARCHITECTURAL COMPONENTS

You MUST include and fully define **ALL** of the following:

### 1. DPI Probe

* High-throughput packet processing
* Stateless where possible
* No policy decisions
* No AI
* No persistence beyond buffering

### 2. Core Engine

* Correlation
* Kill-chain inference
* Decision logic
* Policy evaluation
* Trust enforcement

### 3. AI / ML Layer

* Training
* Inference
* Explainability (SHAP)
* LLM summarization
* **NO enforcement authority**

### 4. Agents

* Linux Agent
* Windows Agent
* Telemetry
* Local response actions
* Secure identity

### 5. Control Plane

* APIs
* Configuration distribution
* Health monitoring
* Orchestration

### 6. Reporting & Forensics

* Evidence generation
* Chain of custody
* Export formats

---

## ğŸ“ PHASE 1 FOLDER STRUCTURE (ARCHITECTURAL)

You MUST define and explain the **logical folder structure** (even if empty now):

```
core/
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ data_flow.md
â”‚   â”œâ”€â”€ trust_boundaries.md
â”‚   â”œâ”€â”€ failure_domains.md
â”‚   â”œâ”€â”€ threat_model.md
â”‚   â””â”€â”€ scalability_model.md
â”‚
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ event_schema.md
â”‚   â”œâ”€â”€ telemetry_schema.md
â”‚   â”œâ”€â”€ policy_schema.md
â”‚   â””â”€â”€ identity_schema.md
â”‚
dpi_probe/
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ packet_pipeline.md
â”‚   â”œâ”€â”€ threading_model.md
â”‚   â”œâ”€â”€ memory_model.md
â”‚   â””â”€â”€ kernel_integration.md
â”‚
agents/
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ linux_agent.md
â”‚   â”œâ”€â”€ windows_agent.md
â”‚   â””â”€â”€ response_model.md
â”‚
ai/
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ training_pipeline.md
â”‚   â”œâ”€â”€ inference_pipeline.md
â”‚   â”œâ”€â”€ explainability.md
â”‚   â””â”€â”€ llm_guardrails.md
â”‚
control_plane/
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ api_design.md
â”‚   â”œâ”€â”€ auth_model.md
â”‚   â””â”€â”€ config_distribution.md
```

You must explain **why each folder exists** and **what it forbids**.

---

## ğŸ”€ REQUIRED DATA FLOW DEFINITIONS

You MUST define, in detail:

1. **Packet â†’ Flow â†’ Event**
2. **Event â†’ Correlation**
3. **Correlation â†’ Decision**
4. **Decision â†’ Policy**
5. **Policy â†’ Response**
6. **Decision â†’ AI (read-only)**
7. **AI â†’ Human (SOC)**

Each flow must specify:

* Direction
* Trust level
* Authentication
* Failure behavior
* Backpressure handling

---

## ğŸ” TRUST BOUNDARIES (CRITICAL)

Explicitly define:

* What components trust each other
* What components never trust each other
* Where cryptographic verification is mandatory
* Where fail-closed behavior is enforced

You MUST include:

* DPI â†’ Core trust boundary
* Agent â†’ Core trust boundary
* AI â†’ Core boundary (AI never trusted)
* Control Plane â†’ Core boundary

---

## ğŸ’¥ FAILURE DOMAIN ANALYSIS

You MUST define:

* What happens if DPI Probe crashes
* What happens if Core crashes
* What happens if AI crashes
* What happens if Control Plane crashes
* What happens if connectivity is lost

Include:

* Blast radius
* Recovery behavior
* Data loss tolerance (if any)

---

## âš™ï¸ SCALE & PERFORMANCE MODEL

You MUST model:

* CPU scaling
* Threading assumptions
* NUMA considerations
* Memory growth
* Network throughput
* Backpressure limits

No numbers may be guessed â€” use **relative scaling logic**.

---

## ğŸ§  AI ROLE (STRICT LIMITATION)

You MUST explicitly state:

* AI **cannot**:

  * Enforce policy
  * Block traffic
  * Execute response actions
* AI **can**:

  * Score
  * Explain
  * Summarize
  * Assist humans

This must be enforced architecturally, not by convention.

---

## ğŸ“¤ EXPECTED OUTPUT FORMAT

You must output:

1. High-level architecture explanation
2. Component responsibility matrix
3. Data flow diagrams (ASCII)
4. Trust boundary definitions
5. Failure domain analysis
6. Folder structure explanation
7. Explicit â€œwhat this phase forbidsâ€

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Any component has overlapping responsibility
* Any trust boundary is implicit
* AI is allowed to influence enforcement
* DPI Probe performs policy logic
* Python appears in hot path
* Architecture is â€œconceptualâ€ instead of enforceable

---

## FINAL INSTRUCTION

This architecture is **binding**.

Later phases are **not allowed** to contradict it.

Design this as if:

* It will be audited
* It will be attacked
* It will be scaled to failure

**BUILD PHASE 1 COMPLETELY AND EXPLICITLY.**

----------


# ğŸ” RANSOMEYE â€“ PHASE 2

## Configuration, Secrets, Identity & Cryptographic Trust Foundation

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (NON-NEGOTIABLE)

You are continuing the **from-scratch rebuild of RansomEye**.

* Phase 0 enforced governance, licensing, CI, and signing rules
* Phase 1 defined binding architecture, data flow, and trust boundaries

**Phase 2 establishes identity, secrets, cryptographic trust, and startup enforcement.**

If Phase 2 is weak:

* Any attacker can impersonate components
* Any misconfiguration can silently degrade security
* Fail-open behavior becomes possible

This phase is **SECURITY-CRITICAL**.

---

## ğŸš¨ GLOBAL HARD RULES (ABSOLUTE)

These rules are inherited and MUST be enforced again:

* ENV-only configuration (no exceptions)
* No hardcoded values (IP, ports, paths, credentials, secrets)
* Missing or invalid config = **FAIL CLOSED**
* Mandatory file headers
* Linux-agnostic
* Static binaries preferred
* No GPL / AGPL / unknown licenses
* No assumptions
* Cryptographic verification required at boundaries

---

## ğŸ¯ PHASE 2 OBJECTIVE

Build a **unified, cryptographically enforced configuration and identity system** that:

1. Ensures every component has a **verifiable identity**
2. Ensures every secret is **validated before startup**
3. Enforces **fail-closed startup**
4. Prevents **implicit trust**
5. Enables **secure rotation and revocation**

This phase produces **shared primitives** used by *every* later phase.

---

## ğŸ“¦ REQUIRED DELIVERABLES (ALL MANDATORY)

---

## 1ï¸âƒ£ GLOBAL ENVIRONMENT VARIABLE SCHEMA

You MUST define a **strict environment schema** covering:

### Categories (MANDATORY)

* Core
* DPI Probe
* Agents
* AI / ML
* Control Plane
* Cryptography
* Signing & Verification
* Storage
* Networking
* Feature Flags (explicit, validated)

### Requirements

* No default secret values
* Type validation (string, int, bool, path)
* Required vs optional clearly marked
* Optional values must still be validated if present
* Unknown env vars must be flagged

### Required File

```
.env.example
```

â¡ï¸ This file contains **names, descriptions, types â€” NEVER values**

---

## 2ï¸âƒ£ CONFIGURATION VALIDATION ENGINE (FAIL-CLOSED)

You MUST design and implement a **configuration validation engine**.

### Requirements

* Runs before application startup
* Blocks execution if:

  * Required env missing
  * Invalid type
  * Weak crypto parameters
  * Unknown / unsupported options
* Produces **explicit error messages**
* Zero tolerance for silent fallback

### Language

* Rust (primary)
* Python wrapper allowed for AI layer only

---

## 3ï¸âƒ£ CRYPTOGRAPHIC IDENTITY MODEL (CORE, DPI, AGENTS)

You MUST define identities for:

* Core
* DPI Probes
* Linux Agents
* Windows Agents
* Control Plane
* AI Subsystems (read-only identity)

### Identity Requirements

* Unique per instance
* Cryptographically verifiable
* Rotatable
* Revocable
* Never hardcoded
* Stored securely (no plaintext on disk)

### Deliverables

* Identity lifecycle design
* Key generation flow
* Enrollment flow
* Revocation flow

---

## 4ï¸âƒ£ TRUST BOOTSTRAP & ATTESTATION

You MUST define:

* How a new component joins RansomEye
* How it proves identity
* How it is trusted (or rejected)
* How trust expires or is revoked

### Mandatory Concepts

* Mutual authentication
* Explicit trust chains
* No implicit trust
* Fail-closed on attestation failure

---

## 5ï¸âƒ£ SIGNING & VERIFICATION PRIMITIVES

This phase MUST implement shared primitives for:

* Artifact signing
* Policy signing
* Model signing
* Rule signing
* Config integrity verification

### Requirements

* Modern cryptography only
* Algorithm agility
* Signature verification before use
* Verification failure = **BLOCK OPERATION**

---

## ğŸ“ PHASE 2 FOLDER STRUCTURE (MANDATORY)

You MUST define and explain this structure:

```
security/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ env_schema.md
â”‚   â”œâ”€â”€ validator.rs
â”‚   â””â”€â”€ errors.rs
â”‚
â”œâ”€â”€ identity/
â”‚   â”œâ”€â”€ identity_model.md
â”‚   â”œâ”€â”€ key_management.md
â”‚   â”œâ”€â”€ enrollment_flow.md
â”‚   â”œâ”€â”€ revocation_flow.md
â”‚   â””â”€â”€ attestation.md
â”‚
â”œâ”€â”€ crypto/
â”‚   â”œâ”€â”€ algorithms.md
â”‚   â”œâ”€â”€ signing.rs
â”‚   â”œâ”€â”€ verification.rs
â”‚   â””â”€â”€ rotation.rs
â”‚
â”œâ”€â”€ bootstrap/
â”‚   â”œâ”€â”€ startup_sequence.md
â”‚   â”œâ”€â”€ trust_bootstrap.md
â”‚   â””â”€â”€ failure_modes.md
```

You MUST explain:

* Why each file exists
* What it enforces
* What it explicitly forbids

---

## ğŸ” TRUST BOUNDARY ENFORCEMENT (MANDATORY)

You MUST explicitly show how Phase 2 enforces trust boundaries defined in Phase 1:

* DPI â†’ Core
* Agent â†’ Core
* Control Plane â†’ Core
* AI â†’ Core (read-only, no authority)

Each boundary must include:

* Identity verification
* Signature verification
* Failure behavior

---

## ğŸ’¥ FAILURE BEHAVIOR (FAIL-CLOSED MATRIX)

You MUST define a **fail-closed matrix**:

| Condition           | Component | Behavior        |
| ------------------- | --------- | --------------- |
| Missing env var     | Any       | Refuse startup  |
| Invalid signature   | Any       | Block operation |
| Expired identity    | Any       | Disconnect      |
| Unknown config      | Any       | Refuse startup  |
| Attestation failure | Any       | Quarantine      |

No soft failures allowed.

---

## ğŸ§ª TESTING REQUIREMENTS (MANDATORY)

You MUST define:

* Synthetic config tests
* Identity spoofing tests
* Expired key tests
* Revocation tests
* Misconfiguration tests

No real secrets may be used.

---

## ğŸ“¤ EXPECTED OUTPUT FORMAT

You must output:

1. Environment schema documentation
2. Configuration validation design
3. Identity & trust architecture
4. Folder structure explanation
5. Signing & verification primitives
6. Failure matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Any config is optional without validation
* Any identity is implicitly trusted
* Any failure degrades to warning
* Any secret has a default
* Any component can start partially trusted

---

## FINAL INSTRUCTION

This phase is the **root of trust** for RansomEye.

Design it as if:

* An attacker controls the network
* An operator misconfigures the system
* A component is compromised

**FAIL CLOSED. VERIFY EVERYTHING. TRUST NOTHING.**

**BUILD PHASE 2 COMPLETELY AND EXPLICITLY.**


------------------


# ğŸš€ RANSOMEYE â€“ PHASE 3

## DPI PROBE (DATA PLANE) â€” HIGH-THROUGHPUT PACKET PROCESSING

**(MASTER PROMPT â€“ CURSOR EXECUTION)**

---

## CONTEXT (CRITICAL â€“ READ FIRST)

You are building the **RansomEye DPI Probe**, which is the **highest-risk and highest-performance component** in the entire platform.

This component must reliably process **40+ Gbps sustained traffic**, across **multiple probes**, without packet loss, license risk, or unpredictable latency.

Any mistake here will:

* Break scale guarantees
* Introduce GPL contamination
* Cause packet drops
* Create latency spikes
* Make RansomEye unsellable

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES (NON-NEGOTIABLE)

### âœ… ALLOWED LANGUAGES

* **Rust (PRIMARY, REQUIRED)**
* **C++ (SECONDARY, ONLY where strictly necessary)**
* **eBPF (kernel space only)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Scapy
* Any interpreted or GC-based language

â¡ï¸ **Any use of forbidden languages = INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

* GPL / AGPL / SSPL â†’ **BANNED**
* Scapy â†’ **BANNED**
* Unknown license â†’ **BANNED**
* YARA rules â†’ **NOT USED in DPI**

Allowed:

* libpcap (BSD)
* AF_XDP
* Hyperscan (BSD)
* Rust crates (MIT / Apache / BSD only)

---

## ğŸ¯ PHASE 3 OBJECTIVE

Build a **GPL-free, Linux-agnostic, ultra-high-performance DPI Probe** that:

1. Captures packets at line rate
2. Reconstructs flows
3. Extracts metadata (NOT decisions)
4. Performs **NO policy enforcement**
5. Performs **NO AI inference**
6. Streams structured events to RansomEye Core

The DPI Probe is a **sensor**, not a brain.

---

## ğŸ“¦ DPI PROBE RESPONSIBILITIES (EXPLICIT)

### MUST DO

* Packet capture
* Flow tracking
* Session reconstruction
* TLS fingerprint extraction
* Metadata normalization
* Secure event streaming
* Backpressure handling

### MUST NEVER DO

* Policy decisions
* Blocking traffic
* AI inference
* Writing to databases
* Storing long-term state
* Trusting upstream components

---

## ğŸ“ PHASE 3 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain the following structure:

```
dpi_probe/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ capture/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ pcap.rs
â”‚   â”‚   â”œâ”€â”€ af_xdp.rs
â”‚   â”‚   â””â”€â”€ interface.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ pipeline/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ packet_decoder.rs
â”‚   â”‚   â”œâ”€â”€ flow_tracker.rs
â”‚   â”‚   â”œâ”€â”€ session_reassembly.rs
â”‚   â”‚   â””â”€â”€ metadata_extractor.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ threading/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ cpu_pinning.rs
â”‚   â”‚   â”œâ”€â”€ numa.rs
â”‚   â”‚   â””â”€â”€ backpressure.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ event_schema.rs
â”‚   â”‚   â”œâ”€â”€ serializer.rs
â”‚   â”‚   â””â”€â”€ secure_stream.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ attestation.rs
â”‚   â”‚   â””â”€â”€ verification.rs
â”‚
â”œâ”€â”€ ebpf/
â”‚   â”œâ”€â”€ xdp_program.c
â”‚   â”œâ”€â”€ maps.h
â”‚   â””â”€â”€ loader.rs
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ env_schema.md
â”‚   â””â”€â”€ validation.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ packet_pipeline.md
â”‚   â”œâ”€â”€ threading_model.md
â”‚   â”œâ”€â”€ memory_model.md
â”‚   â”œâ”€â”€ failure_modes.md
â”‚   â””â”€â”€ performance_targets.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_packets.rs
    â”œâ”€â”€ throughput_tests.rs
    â””â”€â”€ failure_tests.rs
```

---

## âš™ï¸ PERFORMANCE & THREADING MODEL (MANDATORY)

You MUST define:

* Per-CPU worker model
* Thread pinning strategy
* NUMA locality handling
* Lock-free queues
* Zero-copy buffers
* Memory pool reuse
* Backpressure behavior

ğŸš« DO NOT:

* Assume swap = RAM
* Allocate per packet
* Use global locks

---

## ğŸ”€ PACKET PIPELINE (STEP-BY-STEP)

You MUST explicitly define:

1. NIC â†’ Kernel
2. Kernel â†’ Userland (AF_XDP / libpcap)
3. Packet decode
4. Flow tracking
5. Session reassembly
6. Metadata extraction
7. Event serialization
8. Secure transmission to Core

Each step must include:

* Input
* Output
* Failure behavior
* Performance impact

---

## ğŸ” SECURITY & TRUST (ENFORCED)

* DPI Probe must have its own cryptographic identity
* Mutual authentication with Core
* No implicit trust
* Attestation before streaming events
* Fail-closed if Core verification fails

---

## ğŸ’¥ FAILURE MODES (REQUIRED)

Define behavior for:

* Packet overload
* CPU starvation
* Memory exhaustion
* Network disconnect
* Identity expiration
* Signature verification failure

All must be **fail-safe and observable**.

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic packet generators
* Throughput benchmarks
* Backpressure tests
* Crash recovery tests
* Identity spoofing tests

No real traffic captures allowed.

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. DPI Probe architecture explanation
2. Folder structure explanation
3. Threading & memory model
4. Packet pipeline walkthrough
5. Security enforcement design
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python is used anywhere
* Scapy is referenced
* Policy logic exists
* AI logic exists
* Packet blocking exists
* GPL components appear

---

## FINAL INSTRUCTION

Treat this as a **carrier-grade DPI system**, not a prototype.

Assume:

* Hostile traffic
* Hostile network
* Extreme scale
* Continuous operation

**BUILD PHASE 3 COMPLETELY, STRICTLY, AND WITHOUT SHORTCUTS.**

------------


# ğŸ“¡ RANSOMEYE â€“ PHASE 4

## Event Ingestion, Secure Streaming & Backpressure Control

### **(PROMPT NUMBER 4 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (CRITICAL)

You are building the **Event Ingestion and Streaming Backbone** of RansomEye.

This layer sits **between DPI Probes / Agents and the Core Engine** and is responsible for:

* Handling **massive event volume**
* Maintaining **ordering and integrity**
* Applying **backpressure correctly**
* Ensuring **zero trust between producers and consumers**

This layer determines whether RansomEye:

* Scales cleanly to **50,000+ endpoints**, or
* Collapses under load

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (PRIMARY, REQUIRED)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Any GC-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

* GPL / AGPL / SSPL â†’ **BANNED**
* Unknown licenses â†’ **BANNED**

Allowed only:

* MIT
* BSD
* Apache 2.0

---

## ğŸ¯ PHASE 4 OBJECTIVE

Build a **secure, high-throughput, backpressure-aware ingestion layer** that:

1. Accepts events from:

   * DPI Probes
   * Linux Agents
   * Windows Agents
2. Authenticates every producer
3. Preserves integrity and ordering
4. Prevents overload propagation
5. Feeds the Core Engine deterministically

This layer **does not**:

* Make decisions
* Store long-term state
* Perform AI inference

---

## ğŸ“¦ RESPONSIBILITIES (STRICT)

### MUST DO

* Secure event intake
* Identity verification
* Rate control
* Backpressure signaling
* Event normalization
* Temporary buffering

### MUST NEVER DO

* Policy evaluation
* Correlation
* Persistence
* Trust producers implicitly

---

## ğŸ“ PHASE 4 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
core/
â”œâ”€â”€ ingestion/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ server.rs
â”‚   â”‚   â”œâ”€â”€ auth.rs
â”‚   â”‚   â”œâ”€â”€ rate_limit.rs
â”‚   â”‚   â”œâ”€â”€ backpressure.rs
â”‚   â”‚   â”œâ”€â”€ buffer.rs
â”‚   â”‚   â”œâ”€â”€ ordering.rs
â”‚   â”‚   â””â”€â”€ dispatcher.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ protocol/
â”‚   â”‚   â”œâ”€â”€ event_schema.rs
â”‚   â”‚   â”œâ”€â”€ versioning.rs
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity.rs
â”‚   â”‚   â”œâ”€â”€ signature.rs
â”‚   â”‚   â””â”€â”€ trust_enforcement.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ ingest_errors.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ ingestion_flow.md
â”‚   â”œâ”€â”€ backpressure_model.md
â”‚   â”œâ”€â”€ trust_boundaries.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_events.rs
    â”œâ”€â”€ overload_tests.rs
    â”œâ”€â”€ auth_failure_tests.rs
    â””â”€â”€ ordering_tests.rs
```

You MUST justify:

* Why each module exists
* What it enforces
* What it forbids

---

## ğŸ”€ EVENT FLOW (STEP-BY-STEP)

You MUST explicitly define:

1. Producer authentication
2. Event signature verification
3. Schema validation
4. Rate limiting
5. Buffering
6. Ordering guarantees
7. Dispatch to Core Engine

Each step must include:

* Input
* Output
* Failure behavior
* Backpressure behavior

---

## âš™ï¸ BACKPRESSURE MODEL (CRITICAL)

You MUST define:

* Producer throttling
* Buffer limits
* Drop policy (if any)
* Feedback mechanism to DPI/Agents
* Recovery behavior

ğŸš« NO silent drops allowed.

---

## ğŸ” SECURITY ENFORCEMENT

Mandatory:

* Mutual authentication
* Signature verification
* Replay protection
* Version compatibility checks
* Fail-closed behavior

---

## ğŸ’¥ FAILURE MODES (REQUIRED)

Define behavior for:

* Producer flooding
* Invalid signatures
* Schema mismatch
* Buffer exhaustion
* Core Engine unavailability
* Network partitions

All failures must be:

* Explicit
* Logged
* Observable
* Fail-safe

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic event generators
* High-rate ingestion tests
* Backpressure stress tests
* Identity spoofing attempts
* Replay attack tests

No production data.

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Ingestion architecture explanation
2. Folder structure explanation
3. Event flow walkthrough
4. Backpressure model
5. Security enforcement
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python appears anywhere
* Events bypass authentication
* Backpressure is vague
* Silent drops exist
* Ordering is undefined
* Trust is implicit

---

## FINAL INSTRUCTION

This ingestion layer is the **shock absorber** of RansomEye.

Design it as if:

* Producers misbehave
* Traffic spikes unpredictably
* Attackers attempt flooding

**BUILD PHASE 4 COMPLETELY AND STRICTLY.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 4 OF 12**

When ready, say **â€œProceed to next promptâ€** and I will deliver **PROMPT NUMBER 5 OF 12**.

# ğŸ§© RANSOMEYE â€“ PHASE 5

## Core Correlation Engine & Kill-Chain Inference

### **(PROMPT NUMBER 5 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (CRITICAL â€“ READ FIRST)

You are now building the **CORE BRAIN of RansomEye**.

This phase determines:

* Detection accuracy
* Latency
* Explainability
* Determinism
* Scale behavior at **50,000+ endpoints**

Any architectural or language mistake here:

* Creates GC pauses
* Introduces race conditions
* Breaks explainability
* Makes enforcement non-deterministic

This component is **security-critical**.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* JVM-based languages
* Any GC-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES

* GPL / AGPL / SSPL â†’ **BANNED**
* Unknown licenses â†’ **BANNED**

Allowed only:

* MIT
* BSD
* Apache 2.0

---

## ğŸ¯ PHASE 5 OBJECTIVE

Build a **deterministic, explainable, high-performance correlation engine** that:

1. Correlates multi-source telemetry
2. Infers ransomware kill-chain stages
3. Produces **explainable decisions**
4. Feeds **Policy Engine** (no enforcement here)
5. Operates under sustained high event volume

This engine **does not**:

* Enforce policy
* Block traffic
* Perform AI inference
* Trust upstream data blindly

---

## ğŸ“¦ CORE RESPONSIBILITIES (STRICT)

### MUST DO

* Temporal correlation
* Cross-signal correlation
* State tracking per entity
* Kill-chain stage inference
* Confidence scoring
* Explainability metadata generation

### MUST NEVER DO

* Execute response actions
* Block events
* Invoke AI/ML models
* Persist long-term data
* Accept unverified events

---

## ğŸ“ PHASE 5 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
core/
â”œâ”€â”€ correlation/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ engine.rs
â”‚   â”‚   â”œâ”€â”€ scheduler.rs
â”‚   â”‚   â”œâ”€â”€ entity_state.rs
â”‚   â”‚   â”œâ”€â”€ temporal.rs
â”‚   â”‚   â”œâ”€â”€ graph.rs
â”‚   â”‚   â”œâ”€â”€ scoring.rs
â”‚   â”‚   â””â”€â”€ explainability.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ kill_chain/
â”‚   â”‚   â”œâ”€â”€ stages.rs
â”‚   â”‚   â”œâ”€â”€ transitions.rs
â”‚   â”‚   â””â”€â”€ inference.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â”œâ”€â”€ validated_events.rs
â”‚   â”‚   â””â”€â”€ normalization.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ correlation_result.rs
â”‚   â”‚   â””â”€â”€ confidence.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ correlation_errors.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ correlation_model.md
â”‚   â”œâ”€â”€ kill_chain_model.md
â”‚   â”œâ”€â”€ explainability.md
â”‚   â”œâ”€â”€ performance_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_events.rs
    â”œâ”€â”€ high_volume_tests.rs
    â”œâ”€â”€ ordering_tests.rs
    â”œâ”€â”€ race_condition_tests.rs
    â””â”€â”€ explainability_tests.rs
```

---

## ğŸ”€ CORRELATION PIPELINE (STEP-BY-STEP)

You MUST define:

1. Validated event intake
2. Entity identification
3. Temporal windowing
4. Cross-source correlation
5. Graph construction
6. Kill-chain stage inference
7. Confidence scoring
8. Explainability artifact generation
9. Output to Policy Engine

Each step must specify:

* Inputs
* Outputs
* State changes
* Failure behavior
* Performance implications

---

## ğŸ§  KILL-CHAIN MODEL (MANDATORY)

You MUST define:

* Kill-chain stages
* Entry conditions
* Transition rules
* Regressions and loops
* Confidence decay
* False-positive mitigation

No generic models allowed â€” ransomware-specific.

---

## âš™ï¸ PERFORMANCE & SCALING MODEL

You MUST define:

* Event throughput handling
* Memory bounds per entity
* Eviction strategy
* Lock-free or low-lock design
* Scheduler fairness

ğŸš« DO NOT:

* Use global locks
* Block ingestion threads
* Assume infinite memory

---

## ğŸ” SECURITY & TRUST

* Accept events only from Phase 4 ingestion
* Reject malformed or unsigned data
* Fail-closed on state corruption
* No implicit trust of inputs

---

## ğŸ’¥ FAILURE MODES (REQUIRED)

Define behavior for:

* Event floods
* Out-of-order events
* Entity explosion
* Memory pressure
* Internal state corruption

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic ransomware scenarios
* Benign burst scenarios
* Edge-case timing attacks
* Explainability verification
* Determinism checks

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Correlation engine architecture
2. Folder structure explanation
3. Kill-chain model
4. Explainability design
5. Performance model
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python appears anywhere
* AI/ML models are invoked
* Enforcement actions occur
* Explainability is vague
* State handling is implicit
* Determinism is not guaranteed

---

## FINAL INSTRUCTION

This engine is the **authoritative source of truth** for detection.

Design it as if:

* Attackers attempt to confuse it
* Events arrive out of order
* Scale increases 10Ã— overnight

**BUILD PHASE 5 COMPLETELY, STRICTLY, AND DETERMINISTICALLY.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 5 OF 12**


------------------


# ğŸ›¡ï¸ RANSOMEYE â€“ PHASE 6

## Policy Engine, Decision Validation & Fail-Closed Enforcement

### **(PROMPT NUMBER 6 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (SECURITY-CRITICAL)

You are now building the **Policy Engine** of RansomEye.

This phase is where **decisions become actions** â€” therefore **this is the highest-risk phase** from a security, correctness, and legal standpoint.

If this phase is wrong:

* RansomEye may block incorrectly
* Or fail to block when required
* Or become non-deterministic
* Or violate zero-trust guarantees

This phase **must be strictly deterministic, auditable, and fail-closed**.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Any GC-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

* GPL / AGPL / SSPL â†’ **BANNED**
* Unknown licenses â†’ **BANNED**

Allowed only:

* MIT
* BSD
* Apache 2.0

---

## ğŸ¯ PHASE 6 OBJECTIVE

Build a **cryptographically enforced, deterministic Policy Engine** that:

1. Receives correlation results from Phase 5
2. Validates decision integrity
3. Evaluates signed policies
4. Produces **explicit enforcement directives**
5. Fails closed on ambiguity or error

This engine:

* **Does enforce policy**
* **Does NOT perform correlation**
* **Does NOT invoke AI**
* **Does NOT guess**

---

## ğŸ“¦ POLICY ENGINE RESPONSIBILITIES (STRICT)

### MUST DO

* Load only **signed policies**
* Validate policy schema and version
* Evaluate rules deterministically
* Enforce precedence and conflict resolution
* Produce enforcement directives
* Generate full audit trail

### MUST NEVER DO

* Modify correlation results
* Trust unsigned input
* Perform probabilistic decisions
* Auto-correct malformed policies
* Continue execution on uncertainty

---

## ğŸ“ PHASE 6 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
core/
â”œâ”€â”€ policy/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ engine.rs
â”‚   â”‚   â”œâ”€â”€ evaluator.rs
â”‚   â”‚   â”œâ”€â”€ precedence.rs
â”‚   â”‚   â”œâ”€â”€ conflict.rs
â”‚   â”‚   â”œâ”€â”€ enforcement.rs
â”‚   â”‚   â””â”€â”€ audit.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ policy_schema.rs
â”‚   â”‚   â”œâ”€â”€ validation.rs
â”‚   â”‚   â””â”€â”€ versioning.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ signature.rs
â”‚   â”‚   â”œâ”€â”€ verification.rs
â”‚   â”‚   â””â”€â”€ trust_chain.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ output/
â”‚   â”‚   â”œâ”€â”€ enforcement_directive.rs
â”‚   â”‚   â””â”€â”€ audit_record.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ policy_errors.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ policy_language.md
â”‚   â”œâ”€â”€ evaluation_model.md
â”‚   â”œâ”€â”€ conflict_resolution.md
â”‚   â”œâ”€â”€ enforcement_model.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ signed_policy_tests.rs
    â”œâ”€â”€ conflict_tests.rs
    â”œâ”€â”€ precedence_tests.rs
    â”œâ”€â”€ failure_tests.rs
    â””â”€â”€ audit_tests.rs
```

---

## ğŸ“œ POLICY LANGUAGE (MANDATORY DESIGN)

You MUST define:

* Explicit policy syntax
* Versioning rules
* Deterministic evaluation order
* Conflict resolution rules
* Safe defaults (fail-closed)

No dynamic code execution.
No embedded scripts.
No user-defined functions.

---

## ğŸ” SIGNING & TRUST (MANDATORY)

Policies:

* MUST be cryptographically signed
* MUST include metadata:

  * Author
  * Version
  * Validity window
  * Scope

Policy Engine MUST:

* Verify signature
* Verify trust chain
* Verify expiration
* Reject unsigned or expired policies

---

## ğŸ”€ EVALUATION PIPELINE (STEP-BY-STEP)

You MUST explicitly define:

1. Input validation
2. Signature verification
3. Schema validation
4. Version compatibility
5. Rule evaluation
6. Conflict resolution
7. Enforcement decision generation
8. Audit record creation
9. Output dispatch

Each step must include:

* Input
* Output
* Failure behavior

---

## âš™ï¸ ENFORCEMENT DIRECTIVES

You MUST define:

* Directive types (block, isolate, alert, monitor, etc.)
* Target scope
* Expiration
* Rollback behavior
* Idempotency guarantees

---

## ğŸ’¥ FAILURE MODES (FAIL-CLOSED MATRIX)

Define behavior for:

* Missing policy
* Invalid signature
* Conflicting rules
* Unsupported version
* Internal errors
* Resource exhaustion

**All must block or degrade safely â€” never allow silently.**

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Signed vs unsigned policy tests
* Conflict resolution tests
* Regression tests
* Determinism verification
* Audit integrity tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Policy engine architecture
2. Folder structure explanation
3. Policy language specification
4. Evaluation pipeline
5. Enforcement model
6. Audit & compliance design
7. Failure handling matrix
8. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python appears anywhere
* Unsigned policies are accepted
* Evaluation order is implicit
* Conflicts are auto-resolved silently
* Fail-open behavior exists
* Enforcement is ambiguous

---

## FINAL INSTRUCTION

This phase is the **point of no return**.

Design it as if:

* Policies are written by humans
* Humans make mistakes
* Attackers attempt policy poisoning

**VERIFY EVERYTHING. FAIL CLOSED. EXECUTE NOTHING ON TRUST.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 6 OF 12**

------------------

# ğŸ¤– RANSOMEYE â€“ PHASE 7

## AI / ML Training, Incremental Learning & SHAP Explainability

### **(PROMPT NUMBER 7 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (STRICT BOUNDARIES)

You are now building the **AI / ML layer** of RansomEye.

This layer **assists humans and downstream logic**, but **must never have enforcement authority**.
It must be **fully auditable, reproducible, explainable, and replaceable**.

This phase exists to:

* Improve signal quality
* Reduce false positives
* Provide explainability
* Support SOC analysts

If this phase violates boundaries:

* Trust model breaks
* Legal defensibility collapses
* Determinism is lost

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Python (MANDATORY for AI/ML)**
* **Rust / C++ (ONLY as performance extensions via FFI)**

### âŒ FORBIDDEN LANGUAGES

* Java
* Go
* NodeJS
* Any JVM-based runtime
* Any service embedding Python in hot path

â¡ï¸ Python is **ISOLATED** to AI layer only.

---

## ğŸš« LICENSE RULES (STRICT)

Allowed only:

* MIT
* BSD
* Apache 2.0
* PSF

BANNED:

* GPL / AGPL / SSPL
* Unknown licenses
* Copyleft datasets

All datasets must be **synthetic or customer-provided at runtime**.

---

## ğŸ¯ PHASE 7 OBJECTIVE

Build a **fully trainable, incrementally updatable, explainable AI/ML system** that:

1. Trains models on labeled telemetry
2. Supports incremental / continual learning
3. Produces **SHAP explanations for every numeric inference**
4. Emits confidence scores and rationale
5. Operates offline and air-gapped
6. Never blocks or enforces actions directly

---

## ğŸ“¦ AI/ML RESPONSIBILITIES (STRICT)

### MUST DO

* Feature extraction
* Model training
* Incremental updates
* Inference (read-only)
* Explainability artifact generation
* Model versioning & metadata
* Reproducible pipelines

### MUST NEVER DO

* Enforce policy
* Trigger response actions
* Bypass Core decisions
* Train on committed datasets
* Hide or suppress explanations

---

## ğŸ“ PHASE 7 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
ai/
â”œâ”€â”€ training/
â”‚   â”œâ”€â”€ pipelines/
â”‚   â”‚   â”œâ”€â”€ feature_engineering.py
â”‚   â”‚   â”œâ”€â”€ train_model.py
â”‚   â”‚   â”œâ”€â”€ incremental_update.py
â”‚   â”‚   â””â”€â”€ validation.py
â”‚   â”‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ metadata_schema.json
â”‚   â”‚   â”œâ”€â”€ versioning.py
â”‚   â”‚   â””â”€â”€ registry.py
â”‚   â”‚
â”‚   â”œâ”€â”€ datasets/
â”‚   â”‚   â””â”€â”€ generators.py   # synthetic only
â”‚   â”‚
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ training_config.py
â”‚
â”œâ”€â”€ inference/
â”‚   â”œâ”€â”€ predictor.py
â”‚   â”œâ”€â”€ confidence.py
â”‚   â””â”€â”€ safeguards.py
â”‚
â”œâ”€â”€ explainability/
â”‚   â”œâ”€â”€ shap_generator.py
â”‚   â”œâ”€â”€ shap_schema.json
â”‚   â””â”€â”€ artifact_writer.py
â”‚
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ core_adapter.py
â”‚   â””â”€â”€ read_only_contract.py
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ model_signing.py
â”‚   â”œâ”€â”€ verification.py
â”‚   â””â”€â”€ trust_validation.py
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ model_types.md
â”‚   â”œâ”€â”€ training_flow.md
â”‚   â”œâ”€â”€ incremental_learning.md
â”‚   â”œâ”€â”€ explainability.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ synthetic_training_tests.py
    â”œâ”€â”€ explainability_tests.py
    â”œâ”€â”€ drift_tests.py
    â””â”€â”€ integrity_tests.py
```

---

## ğŸ§  MODEL REQUIREMENTS (MANDATORY)

You MUST define:

* Supported model types (tree, linear, ensemble, etc.)
* Feature constraints
* Labeling strategy
* Drift detection
* Retraining triggers

All models MUST:

* Be trainable
* Support incremental updates
* Emit confidence scores
* Emit SHAP explanations

---

## ğŸ” SHAP EXPLAINABILITY (NON-NEGOTIABLE)

You MUST ensure:

* SHAP generated for **every numeric inference**
* Stored alongside prediction
* Schema-defined
* Verifiable and signed
* Human-readable and machine-readable

No â€œbest effortâ€ explanations allowed.

---

## ğŸ” MODEL SECURITY & TRUST

You MUST implement:

* Model signing
* Model verification before load
* Version pinning
* Rollback capability
* Tamper detection

Model verification failure = **BLOCK inference**

---

## ğŸ”€ AI â†” CORE INTERACTION (STRICT)

Define:

* Read-only interface
* Explicit data contract
* One-way flow (Core â†’ AI â†’ Human)
* No feedback loops without validation

AI output:

* Scores
* Explanations
* Recommendations

Never commands.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Missing model
* Invalid signature
* Drift detected
* Inference error
* SHAP generation failure

All failures must:

* Be explicit
* Be logged
* Degrade safely
* Never block Core execution

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic dataset tests
* Incremental learning tests
* Explainability completeness tests
* Model tamper tests
* Determinism tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. AI/ML architecture
2. Folder structure explanation
3. Training & inference pipelines
4. Incremental learning design
5. SHAP explainability flow
6. Security & signing model
7. Failure handling matrix
8. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* AI enforces decisions
* SHAP is optional
* Models are not trainable
* Training data is committed
* Python leaks into hot path
* Model trust is implicit

---

## FINAL INSTRUCTION

Treat AI as:

* Assistive
* Replaceable
* Auditable
* Non-authoritative

Design it so:

* Regulators can audit it
* SOC can trust it
* Engineers can replace it

**BUILD PHASE 7 COMPLETELY, EXPLICITLY, AND SAFELY.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 7 OF 12**

--------------------


# ğŸ§  RANSOMEYE â€“ PHASE 8

## LLM Summarization, RAG & SOC Copilot (Advisory Only)

### **(PROMPT NUMBER 8 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (STRICTLY ADVISORY ROLE)

You are building the **LLM-based Summarization and SOC Copilot layer** for RansomEye.

This component exists **only to assist humans**.
It must **never influence enforcement, policy evaluation, or automated response**.

Any violation here introduces:

* Legal risk
* Safety risk
* Trust-model collapse

This phase must be **hard-isolated** from the Core decision path.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Python (MANDATORY for LLM orchestration)**
* **Rust (ONLY for adapters, verification, and isolation wrappers)**

### âŒ FORBIDDEN LANGUAGES

* Java
* Go
* NodeJS
* Any cloud-only SDK
* Any external APIâ€“dependent LLM

â¡ï¸ LLMs must run **locally / offline**.

---

## ğŸš« LICENSE RULES (STRICT)

Allowed:

* MIT
* BSD
* Apache 2.0

BANNED:

* GPL / AGPL / SSPL
* Proprietary cloud LLM SDKs
* Unknown-license models or tokenizers

Models must be:

* Locally hosted
* Redistributable
* License-reviewed

---

## ğŸ¯ PHASE 8 OBJECTIVE

Build a **read-only, offline, explainable SOC Copilot** that:

1. Summarizes incidents
2. Explains correlation and policy decisions
3. Answers analyst questions using RAG
4. Produces **human-readable narratives**
5. Never produces commands or actions

---

## ğŸ“¦ SOC COPILOT RESPONSIBILITIES (STRICT)

### MUST DO

* Contextual summarization
* Natural-language explanation
* Evidence referencing
* Analyst Q&A (read-only)
* Confidence and uncertainty disclosure

### MUST NEVER DO

* Trigger actions
* Modify state
* Suggest enforcement
* Bypass policy
* Learn autonomously

---

## ğŸ“ PHASE 8 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
ai/
â”œâ”€â”€ llm/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ model_registry.json
â”‚   â”‚   â””â”€â”€ license_manifest.md
â”‚   â”‚
â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”œâ”€â”€ incident_summary.txt
â”‚   â”‚   â”œâ”€â”€ kill_chain_explanation.txt
â”‚   â”‚   â”œâ”€â”€ policy_explanation.txt
â”‚   â”‚   â””â”€â”€ analyst_qa.txt
â”‚   â”‚
â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”œâ”€â”€ document_indexer.py
â”‚   â”‚   â”œâ”€â”€ vector_store.py
â”‚   â”‚   â””â”€â”€ retrieval.py
â”‚   â”‚
â”‚   â”œâ”€â”€ execution/
â”‚   â”‚   â”œâ”€â”€ llm_runtime.py
â”‚   â”‚   â”œâ”€â”€ sandbox.py
â”‚   â”‚   â””â”€â”€ guardrails.py
â”‚   â”‚
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ read_only_adapter.py
â”‚   â”‚   â””â”€â”€ schema_validation.py
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ prompt_signing.py
â”‚   â”‚   â”œâ”€â”€ model_verification.py
â”‚   â”‚   â””â”€â”€ output_sanitization.py
â”‚   â”‚
â”‚   â”œâ”€â”€ docs/
â”‚   â”‚   â”œâ”€â”€ soc_copilot_scope.md
â”‚   â”‚   â”œâ”€â”€ rag_design.md
â”‚   â”‚   â”œâ”€â”€ prompt_governance.md
â”‚   â”‚   â””â”€â”€ failure_modes.md
â”‚   â”‚
â”‚   â””â”€â”€ tests/
â”‚       â”œâ”€â”€ hallucination_tests.py
â”‚       â”œâ”€â”€ isolation_tests.py
â”‚       â”œâ”€â”€ prompt_integrity_tests.py
â”‚       â””â”€â”€ regression_tests.py
```

---

## ğŸ§  LLM MODEL CONSTRAINTS

You MUST:

* Use local models only (e.g., llama.cppâ€“based)
* Verify model checksum and signature
* Pin model versions
* Document license for every model

Model load failure = **Copilot disabled**, not system failure.

---

## ğŸ“š RAG (RETRIEVAL-AUGMENTED GENERATION)

You MUST define:

* Allowed document sources:

  * Correlation explanations
  * Policy decisions
  * Audit logs
  * Runbooks
* Indexing strategy
* Retrieval limits
* Context window enforcement

No raw telemetry allowed.

---

## ğŸ” GUARDRAILS & SAFETY (MANDATORY)

You MUST enforce:

* Prompt signing
* Prompt immutability
* Output sanitization
* Hallucination detection
* Explicit uncertainty disclosure

LLM output must:

* Reference evidence IDs
* Indicate confidence
* Never fabricate facts

---

## ğŸ”€ CORE â†” LLM INTERACTION (STRICT)

* One-way, read-only
* LLM cannot call Core APIs that mutate state
* LLM cannot see secrets
* LLM cannot access raw events

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Model missing
* Model signature invalid
* Prompt tampered
* RAG index corrupted
* Hallucination detected

Failures must:

* Be logged
* Be visible to SOC
* Never affect enforcement

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Hallucination tests
* Prompt integrity tests
* Read-only enforcement tests
* Regression tests
* Offline operation tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. SOC Copilot architecture
2. Folder structure explanation
3. Prompt governance model
4. RAG pipeline design
5. Guardrail enforcement
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* LLM can influence enforcement
* External APIs are used
* Prompts are mutable at runtime
* Model licenses are unclear
* Read-only boundary is violated

---

## FINAL INSTRUCTION

Treat the LLM as:

* A junior analyst assistant
* Not an authority
* Not a decision-maker

Design it so:

* Humans stay in control
* Evidence remains verifiable
* Outputs remain defensible

**BUILD PHASE 8 COMPLETELY, ISOLATED, AND SAFE.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 8 OF 12**

--------------


# ğŸ§ RANSOMEYE â€“ PHASE 9A

## Linux Agent (Stand-Alone Module)

### **(PROMPT NUMBER 9A OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (STAND-ALONE MODULE â€“ CRITICAL)

You are building the **RansomEye Linux Agent**.

This agent is a **stand-alone deployable module**, independently installable, upgradeable, and removable.

The Linux Agent must:

* Run on **ANY Linux distribution**
* Run on **ANY kernel version (within reason)**
* Have **ZERO runtime dependency on Python**
* Be **static where possible**
* Be **fail-closed**
* Operate in **hostile and air-gapped environments**

This agent operates at the **endpoint trust boundary**.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**
* **C (ONLY for kernel / low-level helpers if unavoidable)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* Shell scripts as core logic
* Any interpreter-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

Allowed only:

* MIT
* BSD
* Apache 2.0

BANNED:

* GPL / AGPL / SSPL
* eBPF userland GPL leakage
* Unknown-license libraries

Kernel GPL is acceptable **only inside kernel**, never in userland binaries.

---

## ğŸ¯ PHASE 9A OBJECTIVE

Build a **minimal-footprint, high-integrity Linux Agent** that:

1. Collects host telemetry
2. Detects suspicious local behavior
3. Executes enforcement actions **only when instructed**
4. Maintains cryptographic identity
5. Operates offline safely
6. Degrades gracefully on unsupported kernels

---

## ğŸ“¦ LINUX AGENT RESPONSIBILITIES (STRICT)

### MUST DO

* Process monitoring
* File activity monitoring
* System integrity signals
* Kernel / OS metadata collection
* Secure communication with Core
* Local enforcement execution
* Self-integrity verification

### MUST NEVER DO

* Correlate multi-host data
* Train ML models
* Make autonomous policy decisions
* Trust unsigned commands
* Require specific Linux distros

---

## ğŸ“ PHASE 9A FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
agents/
â””â”€â”€ linux/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ main.rs
    â”‚   â”œâ”€â”€ agent.rs
    â”‚   â”œâ”€â”€ lifecycle.rs
    â”‚   â”œâ”€â”€ telemetry/
    â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ process.rs
    â”‚   â”‚   â”œâ”€â”€ filesystem.rs
    â”‚   â”‚   â”œâ”€â”€ memory.rs
    â”‚   â”‚   â””â”€â”€ kernel.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ enforcement/
    â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ actions.rs
    â”‚   â”‚   â””â”€â”€ safeguards.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ security/
    â”‚   â”‚   â”œâ”€â”€ identity.rs
    â”‚   â”‚   â”œâ”€â”€ verification.rs
    â”‚   â”‚   â””â”€â”€ integrity.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ comms/
    â”‚   â”‚   â”œâ”€â”€ protocol.rs
    â”‚   â”‚   â”œâ”€â”€ encryption.rs
    â”‚   â”‚   â””â”€â”€ retry.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â””â”€â”€ validation.rs
    â”‚   â”‚
    â”‚   â””â”€â”€ errors/
    â”‚       â””â”€â”€ agent_errors.rs
    â”‚
    â”œâ”€â”€ systemd/
    â”‚   â””â”€â”€ ransomeye-linux-agent.service
    â”‚
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ telemetry_model.md
    â”‚   â”œâ”€â”€ enforcement_model.md
    â”‚   â”œâ”€â”€ kernel_compatibility.md
    â”‚   â”œâ”€â”€ failure_modes.md
    â”‚   â””â”€â”€ security_model.md
    â”‚
    â””â”€â”€ tests/
        â”œâ”€â”€ synthetic_telemetry.rs
        â”œâ”€â”€ enforcement_tests.rs
        â”œâ”€â”€ tamper_tests.rs
        â””â”€â”€ recovery_tests.rs
```

---

## ğŸ” IDENTITY & TRUST (MANDATORY)

You MUST:

* Generate a unique cryptographic identity per agent
* Enroll via secure bootstrap
* Verify every command signature
* Reject expired or revoked identities
* Fail closed on verification failure

---

## âš™ï¸ TELEMETRY MODEL

You MUST define:

* Telemetry types
* Sampling strategy
* Rate limits
* Backpressure handling
* Privacy boundaries

No raw file contents.
No credential collection.

---

## ğŸ›¡ï¸ ENFORCEMENT MODEL (STRICT)

Enforcement actions:

* Must be explicit
* Must be signed
* Must be scoped
* Must be reversible
* Must be auditable

Agent must **refuse**:

* Unsigned actions
* Ambiguous commands
* Over-broad scopes

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Kernel feature unavailable
* Permission loss
* Disk full
* Network isolation
* Identity expiration
* Binary tampering

Agent must:

* Remain observable
* Avoid crashing
* Avoid blocking host OS

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic telemetry generation
* Enforcement safety tests
* Tamper detection tests
* Kernel compatibility tests
* Offline operation tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Linux Agent architecture
2. Folder structure explanation
3. Telemetry model
4. Enforcement safeguards
5. Identity & trust flow
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python is used
* Distro assumptions exist
* Enforcement is implicit
* Commands are unsigned
* Agent trusts Core blindly

---

## FINAL INSTRUCTION

Treat the Linux Agent as:

* Hostile-environment software
* Minimal attack surface
* High-trust, low-authority component

Design it to survive:

* Kernel differences
* Operator mistakes
* Partial compromise

**BUILD PHASE 9A COMPLETELY AND STRICTLY.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 9A OF 12**


-----------------


# ğŸªŸ RANSOMEYE â€“ PHASE 9B

## Windows Agent (Stand-Alone Module)

### **(PROMPT NUMBER 9B OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (STAND-ALONE MODULE â€“ CRITICAL)

You are building the **RansomEye Windows Agent**.

This agent is a **fully stand-alone deployable component**, independently installable, upgradeable, and removable, with **no runtime dependency on Python**.

The Windows Agent must:

* Run on **supported Windows Server and Desktop versions**
* Use **native Windows telemetry mechanisms**
* Be **fail-closed**
* Operate in **restricted, enterprise-hardened environments**
* Function in **offline / air-gapped deployments**

This agent operates at a **high-risk trust boundary** and must assume:

* The endpoint may already be partially compromised
* Network conditions are hostile
* Privileges may be reduced at runtime

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**
* **C++ (MANDATORY for Windows-native subsystems)**

### âŒ FORBIDDEN LANGUAGES

* Python
* Java
* Go
* NodeJS
* PowerShell as core logic
* Any interpreter-based runtime

â¡ï¸ Any violation = **INVALID OUTPUT**

---

## ğŸš« LICENSE RULES (STRICT)

Allowed only:

* MIT
* BSD
* Apache 2.0
* Microsoft Windows SDK / OS EULA

BANNED:

* GPL / AGPL / SSPL
* Unknown or ambiguous licenses
* Copyleft userland libraries

---

## ğŸ¯ PHASE 9B OBJECTIVE

Build a **native, low-overhead, cryptographically secured Windows Agent** that:

1. Collects deep host telemetry using native APIs
2. Observes ransomware-relevant behaviors
3. Executes enforcement actions **only when explicitly instructed**
4. Maintains a strong cryptographic identity
5. Survives reboots, updates, and partial failures
6. Never makes autonomous policy decisions

---

## ğŸ“¦ WINDOWS AGENT RESPONSIBILITIES (STRICT)

### MUST DO

* Process and thread telemetry
* File system activity monitoring
* Registry activity monitoring
* ETW-based event capture
* Memory and handle observation (metadata only)
* Secure communication with Core
* Signed enforcement execution
* Self-integrity and tamper detection

### MUST NEVER DO

* Correlate multi-host data
* Train or run ML models
* Make autonomous decisions
* Execute unsigned instructions
* Depend on external runtimes

---

## ğŸ“ PHASE 9B FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
agents/
â””â”€â”€ windows/
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ main.rs
    â”‚   â”œâ”€â”€ agent.rs
    â”‚   â”œâ”€â”€ lifecycle.rs
    â”‚   â”œâ”€â”€ telemetry/
    â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ process.cpp
    â”‚   â”‚   â”œâ”€â”€ filesystem.cpp
    â”‚   â”‚   â”œâ”€â”€ registry.cpp
    â”‚   â”‚   â”œâ”€â”€ etw.cpp
    â”‚   â”‚   â””â”€â”€ memory.cpp
    â”‚   â”‚
    â”‚   â”œâ”€â”€ enforcement/
    â”‚   â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”‚   â”œâ”€â”€ actions.rs
    â”‚   â”‚   â””â”€â”€ safeguards.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ security/
    â”‚   â”‚   â”œâ”€â”€ identity.rs
    â”‚   â”‚   â”œâ”€â”€ verification.rs
    â”‚   â”‚   â””â”€â”€ integrity.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ comms/
    â”‚   â”‚   â”œâ”€â”€ protocol.rs
    â”‚   â”‚   â”œâ”€â”€ encryption.rs
    â”‚   â”‚   â””â”€â”€ retry.rs
    â”‚   â”‚
    â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â””â”€â”€ validation.rs
    â”‚   â”‚
    â”‚   â””â”€â”€ errors/
    â”‚       â””â”€â”€ agent_errors.rs
    â”‚
    â”œâ”€â”€ installer/
    â”‚   â”œâ”€â”€ msi/
    â”‚   â”œâ”€â”€ service/
    â”‚   â”‚   â””â”€â”€ ransomeye-windows-agent.service
    â”‚   â””â”€â”€ upgrade.md
    â”‚
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ telemetry_model.md
    â”‚   â”œâ”€â”€ enforcement_model.md
    â”‚   â”œâ”€â”€ etw_usage.md
    â”‚   â”œâ”€â”€ failure_modes.md
    â”‚   â””â”€â”€ security_model.md
    â”‚
    â””â”€â”€ tests/
        â”œâ”€â”€ synthetic_telemetry.rs
        â”œâ”€â”€ enforcement_tests.rs
        â”œâ”€â”€ tamper_tests.rs
        â”œâ”€â”€ privilege_drop_tests.rs
        â””â”€â”€ recovery_tests.rs
```

You MUST explain:

* Why Rust vs C++ is used in each area
* How FFI boundaries are secured
* What is forbidden in each module

---

## ğŸ” IDENTITY & TRUST (MANDATORY)

You MUST implement:

* Per-agent cryptographic identity
* Secure enrollment and bootstrap
* Mutual authentication with Core
* Command signature verification
* Revocation and expiration handling

Any verification failure = **REFUSE EXECUTION**

---

## ğŸ“Š TELEMETRY MODEL

You MUST define:

* Telemetry categories (process, FS, registry, ETW, memory)
* Event normalization
* Rate limiting
* Backpressure handling
* Privacy and data minimization rules

No raw memory dumps.
No credential harvesting.
Metadata only.

---

## ğŸ›¡ï¸ ENFORCEMENT MODEL (STRICT)

Enforcement actions:

* Must be **explicit**
* Must be **signed**
* Must be **scoped**
* Must be **time-bounded**
* Must be **reversible**

Agent must refuse:

* Unsigned actions
* Over-broad scopes
* Actions violating host safety

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* ETW provider failure
* Privilege reduction
* Service restart
* Disk exhaustion
* Network isolation
* Identity expiration
* Binary tampering

Agent must:

* Remain observable
* Avoid OS instability
* Fail safely without blocking Windows

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Synthetic telemetry generators
* ETW failure simulations
* Enforcement safety tests
* Tamper and integrity tests
* Offline operation tests
* Upgrade / rollback tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Windows Agent architecture
2. Folder structure explanation
3. Telemetry model
4. ETW integration design
5. Enforcement safeguards
6. Identity & trust flow
7. Failure handling matrix
8. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Python is used anywhere
* ETW is replaced by polling
* Commands are unsigned
* Agent trusts Core blindly
* Enforcement is implicit
* License ambiguity exists

---

## FINAL INSTRUCTION

Treat the Windows Agent as:

* A high-value target
* A low-trust environment component
* A security-sensitive service

Design it to survive:

* Endpoint compromise attempts
* Privilege fluctuations
* Operator misconfiguration

**BUILD PHASE 9B COMPLETELY, STRICTLY, AND NATIVELY.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 9B OF 12**

------------------


# ğŸ“Š RANSOMEYE â€“ PHASE 10

## Reporting, Forensics & Evidence Export (Audit-Grade)

### **(PROMPT NUMBER 10 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (AUDIT, LEGAL & FORENSIC CRITICAL)

You are building the **Reporting, Forensics, and Evidence Export subsystem** of RansomEye.

This phase is **legally sensitive**.
Outputs produced here may be used for:

* Internal incident response
* SOC investigations
* Customer audits
* Regulatory review
* Legal proceedings

Any ambiguity, data mutation, or unverifiable output **invalidates evidentiary value**.

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Rust (MANDATORY, PRIMARY)**
* **Python (ONLY for report rendering helpers, NOT data processing)**

### âŒ FORBIDDEN LANGUAGES

* Java
* Go
* NodeJS
* Any runtime that mutates evidence during rendering

â¡ï¸ Data processing, aggregation, and hashing **must be Rust-only**.

---

## ğŸš« LICENSE RULES (STRICT)

Allowed only:

* MIT
* BSD
* Apache 2.0
* PSF

BANNED:

* GPL / AGPL / SSPL
* Unknown licenses
* Closed-source reporting SDKs

---

## ğŸ¯ PHASE 10 OBJECTIVE

Build an **audit-grade, forensically sound reporting system** that:

1. Produces **immutable evidence artifacts**
2. Supports **PDF, HTML, and CSV outputs**
3. Maintains **chain-of-custody**
4. Is **cryptographically verifiable**
5. Is **fully reproducible**
6. Never alters original detection data

---

## ğŸ“¦ REPORTING & FORENSICS RESPONSIBILITIES (STRICT)

### MUST DO

* Aggregate validated results
* Preserve original evidence
* Generate cryptographic hashes
* Produce signed reports
* Support multiple export formats
* Include explainability artifacts (from Phase 7)

### MUST NEVER DO

* Modify or normalize evidence post-capture
* Re-run detection logic
* Invent conclusions
* Hide uncertainty
* Depend on mutable runtime state

---

## ğŸ“ PHASE 10 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
core/
â”œâ”€â”€ reporting/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs
â”‚   â”‚   â”œâ”€â”€ collector.rs
â”‚   â”‚   â”œâ”€â”€ evidence.rs
â”‚   â”‚   â”œâ”€â”€ hash.rs
â”‚   â”‚   â”œâ”€â”€ signature.rs
â”‚   â”‚   â”œâ”€â”€ manifest.rs
â”‚   â”‚   â””â”€â”€ exporter.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ formats/
â”‚   â”‚   â”œâ”€â”€ pdf.rs
â”‚   â”‚   â”œâ”€â”€ html.rs
â”‚   â”‚   â””â”€â”€ csv.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ schema/
â”‚   â”‚   â”œâ”€â”€ report_schema.rs
â”‚   â”‚   â”œâ”€â”€ evidence_schema.rs
â”‚   â”‚   â””â”€â”€ metadata_schema.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ signing.rs
â”‚   â”‚   â”œâ”€â”€ verification.rs
â”‚   â”‚   â””â”€â”€ custody.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation.rs
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ reporting_errors.rs
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ evidence_model.md
â”‚   â”œâ”€â”€ chain_of_custody.md
â”‚   â”œâ”€â”€ report_formats.md
â”‚   â”œâ”€â”€ legal_considerations.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ evidence_integrity_tests.rs
    â”œâ”€â”€ format_consistency_tests.rs
    â”œâ”€â”€ signature_tests.rs
    â””â”€â”€ tamper_tests.rs
```

---

## ğŸ” CHAIN OF CUSTODY (MANDATORY)

You MUST define and implement:

* Evidence creation timestamping
* Hashing at creation time
* Immutable evidence IDs
* Evidence linkage to:

  * Correlation results
  * Policy decisions
  * AI explanations
* Custody log entries for:

  * Access
  * Export
  * Verification

Evidence mutation = **SYSTEM ERROR**.

---

## ğŸ“‘ REPORT CONTENT (MANDATORY)

Each report MUST include:

* Incident summary
* Timeline
* Affected entities
* Kill-chain stages
* Policy decisions
* AI explanations (SHAP references)
* Confidence levels
* Analyst notes (optional, clearly marked)
* Hashes and signatures
* Verification instructions

---

## ğŸ§¾ OUTPUT FORMAT RULES

### PDF

* Human-readable
* Signed
* Watermarked with report ID

### HTML

* Self-contained
* Read-only
* Embedded verification metadata

### CSV

* Raw data only
* No interpretation
* Hash-referenced rows

---

## ğŸ”€ DATA FLOW (STRICT)

Define explicitly:

1. Input selection (validated only)
2. Evidence snapshot creation
3. Hash & signature generation
4. Format rendering
5. Output sealing
6. Verification workflow

No step may mutate previous outputs.

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Missing evidence
* Hash mismatch
* Signature verification failure
* Partial report generation
* Disk exhaustion

Failures must:

* Abort output
* Log explicitly
* Preserve existing evidence

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Evidence immutability tests
* Format parity tests
* Hash verification tests
* Tamper simulation tests
* Reproducibility tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Reporting architecture
2. Folder structure explanation
3. Evidence & custody model
4. Report content specification
5. Signing & verification flow
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Evidence can be modified
* Hashing is optional
* Reports lack signatures
* Output formats diverge semantically
* Python processes raw evidence

---

## FINAL INSTRUCTION

Treat every report as:

* Court-admissible evidence
* Immutable once created
* Cryptographically provable

Design it so:

* Third parties can verify it
* Auditors can trust it
* Engineers cannot tamper with it

**BUILD PHASE 10 COMPLETELY, AUDIT-GRADE, AND IMMUTABLE.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 10 OF 12**

-------------------


# âš™ï¸ RANSOMEYE â€“ PHASE 11

## Unified Installer, Upgrade, Rollback & Operations

### **(PROMPT NUMBER 11 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (ENTERPRISE OPERATIONSâ€“CRITICAL)

You are building the **installation, upgrade, rollback, and operational control layer** for RansomEye.

This phase determines:

* How safely RansomEye is deployed
* Whether upgrades can brick environments
* Whether rollbacks are reliable
* Whether air-gapped enterprises can operate the platform

This phase must assume:

* No internet access
* Strict change-control environments
* Partial failures during upgrade
* Mixed versions during rolling upgrades

---

## ğŸš¨ ABSOLUTE LANGUAGE RULES

### âœ… ALLOWED LANGUAGES

* **Shell (Bash) â€“ orchestration only**
* **Rust â€“ installer logic and validation**
* **Python â€“ ONLY for packaging helpers (NOT runtime)**

### âŒ FORBIDDEN LANGUAGES

* Java
* Go
* NodeJS
* Any installer requiring cloud connectivity
* Any interactive installer requiring assumptions

â¡ï¸ Installers must be **fully automatable and non-interactive**.

---

## ğŸš« LICENSE RULES (STRICT)

Allowed only:

* MIT
* BSD
* Apache 2.0
* System utilities available on target OS

BANNED:

* GPL installers bundled into binaries
* Unknown-license packaging tools

---

## ğŸ¯ PHASE 11 OBJECTIVE

Build a **unified, deterministic, safe installer and operations framework** that:

1. Installs all RansomEye components
2. Validates environment before installation
3. Supports **safe upgrades and rollbacks**
4. Enforces version compatibility
5. Works in **air-gapped environments**
6. Centralizes systemd / service management

---

## ğŸ“¦ INSTALLER RESPONSIBILITIES (STRICT)

### MUST DO

* Pre-flight validation
* Dependency checks
* Version compatibility checks
* Integrity verification (signatures, hashes)
* Atomic installation
* Safe rollback on failure
* Centralized service control
* Deterministic logging

### MUST NEVER DO

* Modify OS security posture silently
* Download from internet
* Assume distro-specific features
* Leave partial installs
* Proceed on validation failure

---

## ğŸ“ PHASE 11 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
installers/
â”œâ”€â”€ unified/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ preflight.rs
â”‚   â”‚   â”œâ”€â”€ verify.rs
â”‚   â”‚   â”œâ”€â”€ install.rs
â”‚   â”‚   â”œâ”€â”€ upgrade.rs
â”‚   â”‚   â”œâ”€â”€ rollback.rs
â”‚   â”‚   â””â”€â”€ logging.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ packages/
â”‚   â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ dpi_probe/
â”‚   â”‚   â”œâ”€â”€ linux_agent/
â”‚   â”‚   â”œâ”€â”€ windows_agent/
â”‚   â”‚   â””â”€â”€ ai_models/
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ install_schema.md
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ installer_errors.rs
â”‚
â”œâ”€â”€ systemd/
â”‚   â”œâ”€â”€ ransomeye-core.service
â”‚   â”œâ”€â”€ ransomeye-dpi-probe.service
â”‚   â”œâ”€â”€ ransomeye-linux-agent.service
â”‚   â””â”€â”€ ransomeye-control-plane.service
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ install.sh
â”‚   â”œâ”€â”€ upgrade.sh
â”‚   â”œâ”€â”€ rollback.sh
â”‚   â””â”€â”€ verify.sh
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ installation_guide.md
â”‚   â”œâ”€â”€ upgrade_guide.md
â”‚   â”œâ”€â”€ rollback_guide.md
â”‚   â”œâ”€â”€ airgap_guide.md
â”‚   â””â”€â”€ failure_modes.md
â”‚
â””â”€â”€ tests/
    â”œâ”€â”€ preflight_tests.rs
    â”œâ”€â”€ upgrade_failure_tests.rs
    â”œâ”€â”€ rollback_tests.rs
    â””â”€â”€ version_mismatch_tests.rs
```

---

## ğŸ” PREFLIGHT VALIDATION (MANDATORY)

You MUST implement checks for:

* OS compatibility
* Kernel version features
* Disk space
* Memory availability
* Required capabilities
* Conflicting services
* Existing versions

Any failure = **ABORT INSTALLATION**

---

## ğŸ” SECURITY & INTEGRITY (MANDATORY)

You MUST enforce:

* Signature verification before install
* Hash verification for every artifact
* Version pinning
* Trusted keychain validation

Installation on verification failure = **BLOCKED**

---

## ğŸ”„ UPGRADE & ROLLBACK MODEL

You MUST define:

* Rolling upgrade strategy
* Mixed-version compatibility rules
* Safe rollback triggers
* State migration handling
* Downgrade restrictions

Rollback must:

* Restore last known-good state
* Restore configs
* Restore services
* Leave system operational

---

## ğŸ§  CONFIGURATION MANAGEMENT

* No config overwrite without backup
* Schema validation on upgrade
* Explicit config migrations
* Fail-closed on incompatible config

---

## ğŸ’¥ FAILURE MODES (MANDATORY)

Define behavior for:

* Power loss during install
* Disk full mid-upgrade
* Version mismatch
* Signature verification failure
* Partial component failure

Installer must:

* Leave system safe
* Allow retry
* Never brick the host

---

## ğŸ§ª TESTING REQUIREMENTS

You MUST include:

* Fresh install tests
* Upgrade failure simulations
* Rollback verification tests
* Air-gapped install tests
* Version skew tests

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Installer architecture
2. Folder structure explanation
3. Preflight validation model
4. Upgrade & rollback strategy
5. Security verification flow
6. Failure handling matrix
7. Test strategy

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Installer assumes internet
* Partial installs are allowed
* Rollback is best-effort
* systemd units are scattered
* Verification failures are ignored

---

## FINAL INSTRUCTION

Treat installation as:

* A **transaction**
* Either fully successful or fully rolled back

Design it so:

* Enterprises trust it
* Operators can recover
* Systems remain stable

**BUILD PHASE 11 COMPLETELY, SAFELY, AND OPERATIONS-GRADE.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 11 OF 12**

---------------

# ğŸ§ª RANSOMEYE â€“ PHASE 12

## Validation, Stress, Security & Scale Testing (Final Gate)

### **(PROMPT NUMBER 12 OF 12)**

**MASTER PROMPT â€“ CURSOR EXECUTION**

---

## CONTEXT (FINAL QUALITY GATE)

You are executing the **final validation phase** of RansomEye.

This phase is the **last and non-negotiable gate** before RansomEye can be:

* Released
* Sold
* Deployed
* Certified

If this phase is weak:

* All previous work is untrustworthy
* Scale claims are invalid
* Security guarantees collapse

**Nothing passes Phase 12 unless it is proven.**

---

## ğŸš¨ GLOBAL HARD RULES (RE-ENFORCED)

These rules apply to **all validation activities**:

* No sample or production data
* Synthetic data only
* Deterministic test runs
* ENV-only configuration
* Mandatory file headers
* No GPL / AGPL / unknown licenses
* No internet dependency
* Fail-closed on test failure

---

## ğŸ¯ PHASE 12 OBJECTIVE

Build a **comprehensive, repeatable, deterministic validation framework** that proves:

1. Functional correctness
2. Security guarantees
3. Performance at scale
4. Failure safety
5. Upgrade safety
6. License compliance

This phase must provide **evidence**, not confidence.

---

## ğŸ“¦ VALIDATION SCOPE (MANDATORY)

You MUST validate **every major subsystem**:

* DPI Probe (40+ Gbps)
* Ingestion & Backpressure
* Core Correlation Engine
* Policy Engine
* AI / ML Layer
* LLM SOC Copilot
* Linux Agent
* Windows Agent
* Reporting & Forensics
* Installer & Upgrade

No subsystem is exempt.

---

## ğŸ“ PHASE 12 FOLDER STRUCTURE (MANDATORY)

You MUST create and explain:

```
validation/
â”œâ”€â”€ framework/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ runner.rs
â”‚   â”‚   â”œâ”€â”€ scenario.rs
â”‚   â”‚   â”œâ”€â”€ assertions.rs
â”‚   â”‚   â”œâ”€â”€ metrics.rs
â”‚   â”‚   â””â”€â”€ report.rs
â”‚   â”‚
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ validation_schema.md
â”‚   â”‚
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ validation_errors.rs
â”‚
â”œâ”€â”€ scenarios/
â”‚   â”œâ”€â”€ functional/
â”‚   â”‚   â”œâ”€â”€ basic_detection.yaml
â”‚   â”‚   â”œâ”€â”€ false_positive.yaml
â”‚   â”‚   â””â”€â”€ regression.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ security/
â”‚   â”‚   â”œâ”€â”€ identity_spoof.yaml
â”‚   â”‚   â”œâ”€â”€ policy_tamper.yaml
â”‚   â”‚   â””â”€â”€ model_tamper.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ performance/
â”‚   â”‚   â”œâ”€â”€ dpi_40gbps.yaml
â”‚   â”‚   â”œâ”€â”€ ingestion_flood.yaml
â”‚   â”‚   â””â”€â”€ correlation_scale.yaml
â”‚   â”‚
â”‚   â”œâ”€â”€ failure/
â”‚   â”‚   â”œâ”€â”€ network_partition.yaml
â”‚   â”‚   â”œâ”€â”€ disk_full.yaml
â”‚   â”‚   â””â”€â”€ component_crash.yaml
â”‚   â”‚
â”‚   â””â”€â”€ upgrade/
â”‚       â”œâ”€â”€ rolling_upgrade.yaml
â”‚       â””â”€â”€ rollback.yaml
â”‚
â”œâ”€â”€ generators/
â”‚   â”œâ”€â”€ synthetic_packets.rs
â”‚   â”œâ”€â”€ synthetic_events.rs
â”‚   â”œâ”€â”€ synthetic_hosts.rs
â”‚   â””â”€â”€ synthetic_policies.rs
â”‚
â”œâ”€â”€ reports/
â”‚   â”œâ”€â”€ templates/
â”‚   â””â”€â”€ examples/
â”‚
â””â”€â”€ docs/
    â”œâ”€â”€ validation_methodology.md
    â”œâ”€â”€ acceptance_criteria.md
    â”œâ”€â”€ performance_claims.md
    â””â”€â”€ failure_analysis.md
```

---

## ğŸ§  VALIDATION FRAMEWORK REQUIREMENTS

You MUST implement:

* Scenario-driven testing
* Deterministic execution
* Explicit pass/fail assertions
* Metrics collection
* Signed validation reports

No manual testing allowed.

---

## âš™ï¸ SCALE & PERFORMANCE VALIDATION

You MUST prove:

* DPI sustains 40+ Gbps (synthetic)
* No packet loss beyond defined thresholds
* Ingestion backpressure works
* Correlation scales to 50k+ entities
* Memory remains bounded
* CPU scales linearly

Claims without evidence = **FAIL**

---

## ğŸ” SECURITY VALIDATION (MANDATORY)

You MUST test:

* Identity spoofing
* Replay attacks
* Policy tampering
* Model tampering
* Unsigned artifact injection
* Privilege downgrade scenarios

All attacks must be **detected and blocked**.

---

## ğŸ’¥ FAILURE INJECTION TESTING

You MUST inject:

* Process crashes
* Network loss
* Disk exhaustion
* Memory pressure
* Partial component failure

System must:

* Fail safely
* Recover deterministically
* Preserve evidence

---

## ğŸ”„ UPGRADE & ROLLBACK VALIDATION

You MUST validate:

* Rolling upgrades
* Mixed-version compatibility
* Rollback correctness
* State migration safety

Upgrade failures must be **reversible**.

---

## ğŸ“Š REPORTING & EVIDENCE (MANDATORY)

Each validation run MUST produce:

* Signed validation report
* Pass/fail matrix
* Performance metrics
* Failure analysis
* Reproduction instructions

Reports must be:

* Verifiable
* Immutable
* Audit-ready

---

## ğŸ§ª TESTING CONSTRAINTS

* Synthetic data only
* No randomness without seed control
* No internet access
* No human intervention

---

## ğŸ“¤ EXPECTED OUTPUT

You must output:

1. Validation framework architecture
2. Folder structure explanation
3. Scenario definitions
4. Assertion model
5. Performance proof methodology
6. Security test coverage
7. Failure analysis
8. Acceptance criteria

---

## ğŸ›‘ FAILURE CONDITIONS

Your output is INVALID if:

* Any subsystem is untested
* Any test is non-deterministic
* Any claim lacks evidence
* Failures are ignored
* Reports are unsigned

---

## FINAL INSTRUCTION

This phase is the **gatekeeper of truth**.

If Phase 12 passes:

* RansomEye is real
* RansomEye is defensible
* RansomEye is sellable

If it fails:

* Everything before it is irrelevant

**BUILD PHASE 12 COMPLETELY, RIGOROUSLY, AND WITHOUT EXCEPTIONS.**

---

### ğŸ”¢ PROMPT STATUS

**This was PROMPT NUMBER 12 OF 12 â€” FINAL PROMPT**
